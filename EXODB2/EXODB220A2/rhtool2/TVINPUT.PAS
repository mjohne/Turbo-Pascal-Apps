{*
*
*   Copyright (c) 1992,93 by Richard W. Hansen
*
*   This source code will compile.
*   Full source code available to registered users.
*
*}
(* This file was mangled by Mangler 1.10 (c) Copyright 1993 by Berend de Boer *)
 UNIT TVINPUT ;{$B+} {$X+} {$V-} {$N+} {$I TVDEFS.INC} INTERFACE USES DOS , APP , DIALOGS , DRIVERS , OBJECTS , VIEWS ,
MSGBOX , TVCONST , TVDIALOG , TVSTRING , TVTYPE ;PROCEDURE SETDATEDEFAULTS ;CONST DFREQUIRED =$0001 ;DFRJUSTIFY =$0002 ;
DFLJUSTIFY =$0004 ;DFTRIM =$0008 ;DFHIDE =$0010 ;DFDEFAULTS =$0020 ;CONST HIDECHAR :CHAR ='*';DECIMALPT ='.';
LEFT =TRUE ;RIGHT =FALSE ;CONST ANYCHAR ='X';FORCEUP ='U';FORCELO ='L';ALPHAONLY ='a';UPPERALPHA ='u';LOWERALPHA ='l';
NUMBERONLY ='#';DIGITONLY ='9';HEXONLY ='&';DATEONLY ='@';CONST EDITMASKCHARS :TCHARSET =[ ANYCHAR , FORCEUP , FORCELO ,
ALPHAONLY , UPPERALPHA , LOWERALPHA , NUMBERONLY , DIGITONLY , HEXONLY , DATEONLY ] ;CONST ANYCHARSET :TCHARSET =[ #32..
#255] ;CONST ALPHAONLYSET :TCHARSET =[ '0'.. '9', 'A'.. 'Z', 'a'.. 'z', ' '] ;CONST DIGITONLYSET :TCHARSET =[ '0'.. '9']
;CONST NUMBERONLYSET :TCHARSET =[ '0'.. '9', '-'] ;CONST HEXONLYSET :TCHARSET =[ '0'.. '9', 'A'.. 'F', 'a'.. 'f', '$'] ;
CONST DATEONLYSET :TCHARSET =[ '0'.. '9', ' '] ;CONST DEFAULTDAY :WORD =0 ;DEFAULTYEAR :WORD =0 ;DEFAULTMONTH :WORD =0 ;
TYPE PBXEDITLINE =^TBXEDITLINE ;TBXEDITLINE =OBJECT (TINPUTLINE)PADCHAR :CHAR ;XPOS :BYTE ;FIRST :BYTE ;MASK :PSTRING ;
ID :WORD ;LLABEL :PLABEL ;EDITFLAGS :WORD ;CONSTRUCTOR INIT (VAR BOUNDS :TRECT ;AMASK :STRING );CONSTRUCTOR LOAD
(VAR S :TSTREAM );DESTRUCTOR DONE ;VIRTUAL;PROCEDURE ADDLABEL (ALABEL :PLABEL );FUNCTION DATASIZE :WORD ;VIRTUAL;
PROCEDURE DRAW ;VIRTUAL;FUNCTION EDITTOMASKPOS (POS :INTEGER ):INTEGER ;FUNCTION EMPTY :BOOLEAN ;VIRTUAL;
PROCEDURE GETDATA (VAR REC );VIRTUAL;FUNCTION GETFIELDNAME :STRING ;VIRTUAL;FUNCTION GETID :WORD ;VIRTUAL;
PROCEDURE HANDLEEVENT (VAR EVENT :TEVENT );VIRTUAL;FUNCTION HOMEPOS :INTEGER ;VIRTUAL;PROCEDURE INSERTCHAR (CH :CHAR );
VIRTUAL;FUNCTION MASKTOEDITPOS (POS :INTEGER ):INTEGER ;PROCEDURE LOCK ;PROCEDURE MERGE (VAR ST :STRING ;
JUSTIFY :BOOLEAN );VIRTUAL;FUNCTION NEXTPOS (POS :INTEGER ):INTEGER ;VIRTUAL;FUNCTION PREVPOS (POS :INTEGER ):INTEGER ;
VIRTUAL;FUNCTION REMOVE (CONST ST :STRING ):STRING ;PROCEDURE SETDATA (VAR REC );VIRTUAL;PROCEDURE SETEDITFLAG
(AFLAG :WORD ;ENABLE :BOOLEAN );VIRTUAL;PROCEDURE SETID (AFIELDID :WORD );PROCEDURE SETSTATE (ASTATE :WORD ;
ENABLE :BOOLEAN );VIRTUAL;PROCEDURE STORE (VAR S :TSTREAM );PROCEDURE UNLOCK ;FUNCTION VALID (COMMAND :WORD ):BOOLEAN ;
VIRTUAL;PRIVATE FUNCTION CANSCROLL (SCROLLLEFT :BOOLEAN ):BOOLEAN ;PROCEDURE DELETEMARKED ;PROCEDURE SELECTALL
(ENABLE :BOOLEAN );END ;PBXDATEEDIT =^TBXDATEEDIT ;TBXDATEEDIT =OBJECT (TBXEDITLINE)DATE :PBXDATE ;DATEPIC :TBXDATEST ;
CONSTRUCTOR INIT (VAR BOUNDS :TRECT ;ADATEPIC :TBXDATEST );CONSTRUCTOR LOAD (VAR S :TSTREAM );DESTRUCTOR DONE ;VIRTUAL;
FUNCTION DATASIZE :WORD ;VIRTUAL;PROCEDURE GETDATA (VAR REC );VIRTUAL;PROCEDURE SETDATA (VAR REC );VIRTUAL;
PROCEDURE STORE (VAR S :TSTREAM );FUNCTION VALID (COMMAND :WORD ):BOOLEAN ;VIRTUAL;END ;
PBXNUMERICEDIT =^TBXNUMERICEDIT ;TBXNUMERICEDIT =OBJECT (TBXEDITLINE)ERRCODE :INTEGER ;PROCEDURE HANDLEEVENT
(VAR EVENT :TEVENT );VIRTUAL;FUNCTION OUTOFRANGE :BOOLEAN ;VIRTUAL;FUNCTION OUTOFRANGEMSG :STRING ;VIRTUAL;
FUNCTION VALID (COMMAND :WORD ):BOOLEAN ;VIRTUAL;END ;PBXLONGEDIT =^TBXLONGEDIT ;
TBXLONGEDIT =OBJECT (TBXNUMERICEDIT)MIN :LONGINT ;MAX :LONGINT ;CONSTRUCTOR INIT (VAR BOUNDS :TRECT ;CONST AMASK :STRING
;AMIN :LONGINT ;AMAX :LONGINT );CONSTRUCTOR LOAD (VAR S :TSTREAM );FUNCTION DATASIZE :WORD ;VIRTUAL;PROCEDURE GETDATA
(VAR REC );VIRTUAL;FUNCTION OUTOFRANGE :BOOLEAN ;VIRTUAL;FUNCTION OUTOFRANGEMSG :STRING ;VIRTUAL;PROCEDURE SETDATA
(VAR REC );VIRTUAL;PROCEDURE STORE (VAR S :TSTREAM );END ;PBXHEXEDIT =^TBXHEXEDIT ;
TBXHEXEDIT =OBJECT (TBXLONGEDIT)FUNCTION OUTOFRANGEMSG :STRING ;VIRTUAL;PROCEDURE SETDATA (VAR REC );VIRTUAL;END ;
PBXINTEGEREDIT =^TBXINTEGEREDIT ;TBXINTEGEREDIT =OBJECT (TBXLONGEDIT)CONSTRUCTOR INIT (VAR BOUNDS :TRECT ;
CONST AMASK :STRING ;AMIN :INTEGER ;AMAX :INTEGER );FUNCTION DATASIZE :WORD ;VIRTUAL;PROCEDURE GETDATA (VAR REC );
VIRTUAL;PROCEDURE SETDATA (VAR REC );VIRTUAL;END ;PBXWORDEDIT =^TBXWORDEDIT ;
TBXWORDEDIT =OBJECT (TBXLONGEDIT)CONSTRUCTOR INIT (VAR BOUNDS :TRECT ;CONST AMASK :STRING ;AMIN :WORD ;AMAX :WORD );
FUNCTION DATASIZE :WORD ;VIRTUAL;PROCEDURE GETDATA (VAR REC );VIRTUAL;PROCEDURE SETDATA (VAR REC );VIRTUAL;END ;
PBXBYTEEDIT =^TBXBYTEEDIT ;TBXBYTEEDIT =OBJECT (TBXLONGEDIT)CONSTRUCTOR INIT (VAR BOUNDS :TRECT ;CONST AMASK :STRING ;
AMIN :BYTE ;AMAX :BYTE );FUNCTION DATASIZE :WORD ;VIRTUAL;PROCEDURE GETDATA (VAR REC );VIRTUAL;PROCEDURE SETDATA
(VAR REC );VIRTUAL;END ;PBXFLOATEDIT =^TBXFLOATEDIT ;TBXFLOATEDIT =OBJECT (TBXNUMERICEDIT)DP :BYTE ;CONSTRUCTOR INIT
(VAR BOUNDS :TRECT ;CONST AMASK :STRING );CONSTRUCTOR LOAD (VAR S :TSTREAM );PROCEDURE HANDLEEVENT (VAR EVENT :TEVENT );
VIRTUAL;PROCEDURE STORE (VAR S :TSTREAM );END ;{$IFOPT N+} PBXDOUBLEEDIT =^TBXDOUBLEEDIT ;
TBXDOUBLEEDIT =OBJECT (TBXFLOATEDIT)MIN :DOUBLE ;MAX :DOUBLE ;CONSTRUCTOR INIT (VAR BOUNDS :TRECT ;CONST AMASK :STRING ;
AMIN :DOUBLE ;AMAX :DOUBLE );CONSTRUCTOR LOAD (VAR S :TSTREAM );FUNCTION DATASIZE :WORD ;VIRTUAL;PROCEDURE GETDATA
(VAR REC );VIRTUAL;FUNCTION OUTOFRANGE :BOOLEAN ;VIRTUAL;FUNCTION OUTOFRANGEMSG :STRING ;VIRTUAL;PROCEDURE SETDATA
(VAR REC );VIRTUAL;PROCEDURE STORE (VAR S :TSTREAM );END ;{$ENDIF} PBXREALEDIT =^TBXREALEDIT ;
TBXREALEDIT =OBJECT (TBXFLOATEDIT)MIN :REAL ;MAX :REAL ;CONSTRUCTOR INIT (VAR BOUNDS :TRECT ;CONST AMASK :STRING ;
AMIN :REAL ;AMAX :REAL );CONSTRUCTOR LOAD (VAR S :TSTREAM );FUNCTION DATASIZE :WORD ;VIRTUAL;PROCEDURE GETDATA
(VAR REC );VIRTUAL;FUNCTION OUTOFRANGE :BOOLEAN ;VIRTUAL;FUNCTION OUTOFRANGEMSG :STRING ;VIRTUAL;PROCEDURE SETDATA
(VAR REC );VIRTUAL;PROCEDURE STORE (VAR S :TSTREAM );END ;PBXCHECKBOXES =^TBXCHECKBOXES ;
TBXCHECKBOXES =OBJECT (TCHECKBOXES)ID :WORD ;LLABEL :PLABEL ;EDITFLAGS :WORD ;CONSTRUCTOR INIT (VAR BOUNDS :TRECT ;
ASTRINGS :PSITEM );CONSTRUCTOR LOAD (VAR S :TSTREAM );PROCEDURE ADDLABEL (ALABEL :PLABEL );FUNCTION EMPTY :BOOLEAN ;
VIRTUAL;FUNCTION GETID :WORD ;FUNCTION GETFIELDNAME :STRING ;VIRTUAL;PROCEDURE HANDLEEVENT (VAR EVENT :TEVENT );VIRTUAL;
PROCEDURE LOCK ;PROCEDURE SETEDITFLAG (AFLAG :WORD ;ENABLE :BOOLEAN );VIRTUAL;PROCEDURE SETID (AFIELDID :WORD );
PROCEDURE SETSTATE (ASTATE :WORD ;ENABLE :BOOLEAN );VIRTUAL;PROCEDURE STORE (VAR S :TSTREAM );PROCEDURE UNLOCK ;
FUNCTION VALID (COMMAND :WORD ):BOOLEAN ;VIRTUAL;END ;PBXRADIOBUTTONS =^TBXRADIOBUTTONS ;
TBXRADIOBUTTONS =OBJECT (TRADIOBUTTONS)ID :WORD ;LLABEL :PLABEL ;EDITFLAGS :WORD ;CONSTRUCTOR INIT (VAR BOUNDS :TRECT ;
ASTRINGS :PSITEM );CONSTRUCTOR LOAD (VAR S :TSTREAM );PROCEDURE ADDLABEL (ALABEL :PLABEL );FUNCTION GETFIELDNAME :STRING
;VIRTUAL;FUNCTION GETID :WORD ;PROCEDURE HANDLEEVENT (VAR EVENT :TEVENT );VIRTUAL;PROCEDURE LOCK ;PROCEDURE SETEDITFLAG
(AFLAG :WORD ;ENABLE :BOOLEAN );VIRTUAL;PROCEDURE SETID (AFIELDID :WORD );PROCEDURE SETSTATE (ASTATE :WORD ;
ENABLE :BOOLEAN );VIRTUAL;PROCEDURE STORE (VAR S :TSTREAM );PROCEDURE UNLOCK ;END ;PBXSLIDER =^TBXSLIDER ;
TBXSLIDER =OBJECT (TGROUP)SCROLLBAR :PSCROLLBAR ;ID :WORD ;LLABEL :PLABEL ;EDITFLAGS :WORD ;CONSTRUCTOR INIT
(VAR BOUNDS :TRECT ;AMIN :INTEGER ;AMAX :INTEGER ;CONST AMINLABEL :STRING ;CONST AMAXLABEL :STRING );CONSTRUCTOR LOAD
(VAR S :TSTREAM );PROCEDURE ADDLABEL (ALABEL :PLABEL );PROCEDURE GETDATA (VAR REC );VIRTUAL;FUNCTION GETID :WORD ;
FUNCTION GETFIELDNAME :STRING ;VIRTUAL;PROCEDURE HANDLEEVENT (VAR EVENT :TEVENT );VIRTUAL;PROCEDURE LOCK ;
PROCEDURE SETDATA (VAR REC );VIRTUAL;PROCEDURE SETEDITFLAG (AFLAG :WORD ;ENABLE :BOOLEAN );VIRTUAL;PROCEDURE SETID
(AFIELDID :WORD );PROCEDURE SETSTATE (ASTATE :WORD ;ENABLE :BOOLEAN );VIRTUAL;PROCEDURE STORE (VAR S :TSTREAM );
PROCEDURE UNLOCK ;END ;PBXSPINEDIT =^TBXSPINEDIT ;TBXSPINCHARS =ARRAY [ 1 .. 2 ]  OF CHAR ;PBXSPINBAR =^TBXSPINBAR ;
TBXSPINBAR =OBJECT (TSCROLLBAR)CHARS :TBXSPINCHARS ;SPINEDIT :PBXSPINEDIT ;CONSTRUCTOR INIT (VAR BOUNDS :TRECT );
CONSTRUCTOR LOAD (VAR S :TSTREAM );PROCEDURE DRAW ;VIRTUAL;PROCEDURE HANDLEEVENT (VAR EVENT :TEVENT );VIRTUAL;
PROCEDURE STORE (VAR S :TSTREAM );END ;TBXSPINEDIT =OBJECT (TBXINTEGEREDIT)SPINBAR :PBXSPINBAR ;CONSTRUCTOR INIT
(VAR BOUNDS :TRECT ;CONST AMASK :STRING ;ASPINBAR :PBXSPINBAR );CONSTRUCTOR LOAD (VAR S :TSTREAM );PROCEDURE HANDLEEVENT
(VAR EVENT :TEVENT );VIRTUAL;PROCEDURE SETDATA (VAR REC );VIRTUAL;PROCEDURE STORE (VAR S :TSTREAM );PROCEDURE SETSTATE
(ASTATE :WORD ;ENABLE :BOOLEAN );VIRTUAL;FUNCTION VALID (COMMAND :WORD ):BOOLEAN ;VIRTUAL;END ;
PBXENTRYDIALOG =^TBXENTRYDIALOG ;TBXENTRYDIALOG =OBJECT (TDIALOG)NEXTID :WORD ;CONSTRUCTOR INIT (VAR BOUNDS :TRECT ;
ATITLE :TTITLESTR );CONSTRUCTOR LOAD (VAR S :TSTREAM );FUNCTION FINDFIELD (ID :WORD ):POINTER ;PROCEDURE HANDLEEVENT
(VAR EVENT :TEVENT );VIRTUAL;PROCEDURE INSERT (P :PVIEW );VIRTUAL;PROCEDURE LOCKFIELD (ID :WORD ;ENABLE :BOOLEAN );
PROCEDURE STORE (VAR S :TSTREAM );END ;PROCEDURE REGISTERTVINPUT ;CONST RBXEDITLINE :TSTREAMREC =(OBJTYPE :5300 ;
VMTLINK :OFS (TYPEOF (TBXEDITLINE )^);LOAD :@ TBXEDITLINE . LOAD ;STORE :@ TBXEDITLINE . STORE );
CONST RBXDATEEDIT :TSTREAMREC =(OBJTYPE :5301 ;VMTLINK :OFS (TYPEOF (TBXDATEEDIT )^);LOAD :@ TBXDATEEDIT . LOAD ;
STORE :@ TBXDATEEDIT . STORE );CONST RBXLONGEDIT :TSTREAMREC =(OBJTYPE :5302 ;VMTLINK :OFS (TYPEOF (TBXLONGEDIT )^);
LOAD :@ TBXLONGEDIT . LOAD ;STORE :@ TBXLONGEDIT . STORE );CONST RBXHEXEDIT :TSTREAMREC =(OBJTYPE :5303 ;
VMTLINK :OFS (TYPEOF (TBXHEXEDIT )^);LOAD :@ TBXHEXEDIT . LOAD ;STORE :@ TBXHEXEDIT . STORE );
CONST RBXINTEGEREDIT :TSTREAMREC =(OBJTYPE :5304 ;VMTLINK :OFS (TYPEOF (TBXINTEGEREDIT )^);LOAD :@ TBXINTEGEREDIT .
LOAD ;STORE :@ TBXINTEGEREDIT . STORE );CONST RBXWORDEDIT :TSTREAMREC =(OBJTYPE :5305 ;
VMTLINK :OFS (TYPEOF (TBXWORDEDIT )^);LOAD :@ TBXWORDEDIT . LOAD ;STORE :@ TBXWORDEDIT . STORE );
CONST RBXBYTEEDIT :TSTREAMREC =(OBJTYPE :5306 ;VMTLINK :OFS (TYPEOF (TBXBYTEEDIT )^);LOAD :@ TBXBYTEEDIT . LOAD ;
STORE :@ TBXBYTEEDIT . STORE );{$IFOPT N+} CONST RBXDOUBLEEDIT :TSTREAMREC =(OBJTYPE :5307 ;
VMTLINK :OFS (TYPEOF (TBXDOUBLEEDIT )^);LOAD :@ TBXDOUBLEEDIT . LOAD ;STORE :@ TBXDOUBLEEDIT . STORE );{$ENDIF}
CONST RBXREALEDIT :TSTREAMREC =(OBJTYPE :5308 ;VMTLINK :OFS (TYPEOF (TBXREALEDIT )^);LOAD :@ TBXREALEDIT . LOAD ;
STORE :@ TBXREALEDIT . STORE );CONST RBXENTRYDIALOG :TSTREAMREC =(OBJTYPE :5309 ;
VMTLINK :OFS (TYPEOF (TBXENTRYDIALOG )^);LOAD :@ TBXENTRYDIALOG . LOAD ;STORE :@ TBXENTRYDIALOG . STORE );
CONST RBXCHECKBOXES :TSTREAMREC =(OBJTYPE :5310 ;VMTLINK :OFS (TYPEOF (TBXCHECKBOXES )^);LOAD :@ TBXCHECKBOXES . LOAD ;
STORE :@ TBXCHECKBOXES . STORE );CONST RBXRADIOBUTTONS :TSTREAMREC =(OBJTYPE :5311 ;
VMTLINK :OFS (TYPEOF (TBXRADIOBUTTONS )^);LOAD :@ TBXRADIOBUTTONS . LOAD ;STORE :@ TBXRADIOBUTTONS . STORE );
CONST RBXSLIDER :TSTREAMREC =(OBJTYPE :5312 ;VMTLINK :OFS (TYPEOF (TBXSLIDER )^);LOAD :@ TBXSLIDER . LOAD ;STORE :@
TBXSLIDER . STORE );CONST RBXSPINBAR :TSTREAMREC =(OBJTYPE :5313 ;VMTLINK :OFS (TYPEOF (TBXSPINBAR )^);LOAD :@
TBXSPINBAR . LOAD ;STORE :@ TBXSPINBAR . STORE );CONST RBXSPINEDIT :TSTREAMREC =(OBJTYPE :5314 ;
VMTLINK :OFS (TYPEOF (TBXSPINEDIT )^);LOAD :@ TBXSPINEDIT . LOAD ;STORE :@ TBXSPINEDIT . STORE );
IMPLEMENTATION PROCEDURE SETDATEDEFAULTS ;VAR O1OlOIlOI10I:WORD;BEGIN GETDATE (DEFAULTYEAR , DEFAULTMONTH , DEFAULTDAY ,
O1OlOIlOI10I );END ;FUNCTION OI1I1I10lIOI (OIOI:CHAR):CHAR ;BEGIN ASM {} MOV AL , OIOI{} CMP AL , 'A' {} JB @1 {}
CMP AL , 'Z' {} JA @1 {} ADD AL , 'a' - 'A' {} @1 : MOV @RESULT , AL {} {} END;END ;CONSTRUCTOR TBXEDITLINE.INIT
(VAR BOUNDS:TRECT;AMASK:STRING );VAR OIlO:BYTE;OOIO:BYTE;BEGIN OOIO := 0 ;IF (AMASK ='')THEN AMASK := 'X';FOR OIlO := 1
TO BYTE (AMASK [ 0 ] ) DO IF (AMASK [ OIlO ] IN EDITMASKCHARS )THEN INC (OOIO );INHERITED INIT(BOUNDS , OOIO );MASK :=
NEWSTR (AMASK );FIRST := 1 ;PADCHAR := ' ';WHILE (FIRST <= BYTE (MASK ^[ 0 ] ))AND NOT (AMASK [ FIRST ] IN EDITMASKCHARS
) DO INC (FIRST );LLABEL := NIL ;ID := 0 ;EDITFLAGS := 0 ;EVENTMASK := EVENTMASK OR EVBROADCAST ;END ;
DESTRUCTOR TBXEDITLINE.DONE ;BEGIN INHERITED DONE;DISPOSESTR (MASK );END ;CONSTRUCTOR TBXEDITLINE.LOAD (VAR S:TSTREAM);
BEGIN INHERITED LOAD(S );S.READ (PADCHAR , SIZEOF (CHAR ));S.READ (XPOS , SIZEOF (BYTE ));S.READ (FIRST , SIZEOF (FIRST
));MASK := S.READSTR ;S.READ (ID , SIZEOF (BYTE ));GETPEERVIEWPTR (S , LLABEL );S.READ (EDITFLAGS , SIZEOF (WORD ));
END ;PROCEDURE TBXEDITLINE.ADDLABEL (ALABEL:PLABEL);BEGIN LLABEL := ALABEL ;END ;FUNCTION TBXEDITLINE.CANSCROLL
(SCROLLLEFT:BOOLEAN):BOOLEAN ;BEGIN IF ((EDITFLAGS AND DFRJUSTIFY )<> 0 )THEN CANSCROLL := FALSE ELSE IF SCROLLLEFT THEN
CANSCROLL := (FIRSTPOS > 1 )ELSE CANSCROLL := ((LENGTH (MASK ^)- FIRSTPOS + 1 )> (SIZE.X - 2 ));END ;
FUNCTION TBXEDITLINE.DATASIZE :WORD ;BEGIN DATASIZE := LENGTH (MASK ^)+ 1 ;END ;PROCEDURE TBXEDITLINE.DELETEMARKED ;
BEGIN IF (SELSTART <> SELEND )THEN BEGIN DELETE (DATA ^, SELSTART , SELEND - SELSTART + 1 );XPOS := SELSTART ;CURPOS :=
EDITTOMASKPOS (XPOS );END ;END ;PROCEDURE TBXEDITLINE.DRAW ;VAR O11lIOII:STRING ;OOllOI000O1l:BYTE;OIO1:TDRAWBUFFER;
OO01,OO1I:INTEGER;BEGIN MERGE (O11lIOII , (STATE AND SFSELECTED =0 ));IF (STATE AND SFFOCUSED =0 )THEN OOllOI000O1l :=
GETCOLOR (1 )ELSE OOllOI000O1l := GETCOLOR (2 );MOVECHAR (OIO1 , ' ', OOllOI000O1l , SIZE.X );MOVESTR (OIO1 [ 1 ] , COPY
(O11lIOII , FIRSTPOS , SIZE.X - 2 ), OOllOI000O1l );IF CANSCROLL (RIGHT )THEN MOVECHAR (OIO1 [ SIZE.X - 1 ] , #16,
GETCOLOR (4 ), 1 );IF (STATE AND SFSELECTED <> 0 )THEN BEGIN IF CANSCROLL (LEFT )THEN MOVECHAR (OIO1 [ 0 ] , #17,
GETCOLOR (4 ), 1 );OO01 := SELSTART - FIRSTPOS + 1 ;IF (OO01 < 1 )THEN OO01 := 1 ;OO1I := SELEND - FIRSTPOS + 1 ;IF (OO1I
> SIZE.X - 1 )THEN OO1I := SIZE.X - 1 ;IF (OO01 < OO1I )THEN MOVECHAR (OIO1 [ OO01 ] , #0, GETCOLOR (3 ), OO1I - OO01 + 1
);END ;WRITELINE (0 , 0 , SIZE.X , SIZE.Y , OIO1 );SETCURSOR (CURPOS - FIRSTPOS + 1 , 0 );END ;
FUNCTION TBXEDITLINE.EDITTOMASKPOS (POS:INTEGER):INTEGER ;VAR OOIO:INTEGER;OIOO101OlII:INTEGER;BEGIN OIOO101OlII := 0 ;
FOR OOIO := 1 TO POS  DO REPEAT INC (OIOO101OlII );UNTIL (MASK ^[ OIOO101OlII ] IN EDITMASKCHARS );EDITTOMASKPOS :=
OIOO101OlII ;END ;FUNCTION TBXEDITLINE.EMPTY :BOOLEAN ;BEGIN EMPTY := ALLBLANKS (DATA ^);END ;
PROCEDURE TBXEDITLINE.GETDATA (VAR REC);VAR OIOI100IlI0:STRING ;OOIlOl0l0l1l:WORD;BEGIN OOIlOl0l0l1l := EDITFLAGS ;
EDITFLAGS := EDITFLAGS AND NOT DFHIDE ;MERGE (OIOI100IlI0 , TRUE );EDITFLAGS := OOIlOl0l0l1l ;MOVE (OIOI100IlI0 , REC ,
DATASIZE );END ;FUNCTION TBXEDITLINE.GETFIELDNAME :STRING ;VAR OI111IlIOOl0:STRING ;BEGIN IF (LLABEL <> NIL )THEN
BEGIN OI111IlIOOl0 := PLABEL (LLABEL )^. TEXT ^;STRIP (OI111IlIOOl0 , [ '~'] );END ELSE OI111IlIOOl0 := '';GETFIELDNAME
:= OI111IlIOOl0 ;END ;FUNCTION TBXEDITLINE.GETID :WORD ;BEGIN GETID := ID ;END ;PROCEDURE TBXEDITLINE.HANDLEEVENT
(VAR EVENT:TEVENT);FUNCTION O10O11lIO100O (VAR OIOl00O1O1O:BOOLEAN):BOOLEAN ;VAR OI1I1O1lll10:TPOINT;BEGIN MAKELOCAL
(EVENT.WHERE , OI1I1O1lll10 );IF (OI1I1O1lll10.X <= 0 )THEN BEGIN O10O11lIO100O := TRUE ;OIOl00O1O1O := LEFT ;END ELSE IF
(OI1I1O1lll10.X >= SIZE.X - 1 )THEN BEGIN O10O11lIO100O := TRUE ;OIOl00O1O1O := RIGHT ;END ELSE BEGIN O10O11lIO100O :=
FALSE ;END ;END ;FUNCTION Ol1lIl0010 :INTEGER ;VAR OIOllI0O1OI:INTEGER;OI1I1O1lll10:TPOINT;BEGIN MAKELOCAL (EVENT.WHERE ,
OI1I1O1lll10 );IF (OI1I1O1lll10.X < 1 )THEN OI1I1O1lll10.X := 1 ;OIOllI0O1OI := OI1I1O1lll10.X + FIRSTPOS - 1 ;IF
(OIOllI0O1OI < 1 )THEN OIOllI0O1OI := 1 ELSE IF (OIOllI0O1OI > EDITTOMASKPOS (LENGTH (DATA ^)))THEN OIOllI0O1OI :=
EDITTOMASKPOS (LENGTH (DATA ^));IF NOT (MASK ^[ OIOllI0O1OI ] IN EDITMASKCHARS )THEN OIOllI0O1OI := NEXTPOS (OIOllI0O1OI
);IF NOT (MASK ^[ OIOllI0O1OI ] IN EDITMASKCHARS )THEN OIOllI0O1OI := PREVPOS (OIOllI0O1OI );Ol1lIl0010 := OIOllI0O1OI ;
END ;PROCEDURE OIO101I1O1I (OIOl00O1O1O:BOOLEAN);BEGIN IF CANSCROLL (OIOl00O1O1O )THEN BEGIN IF (OIOl00O1O1O =LEFT )THEN
BEGIN DEC (XPOS );DEC (FIRSTPOS );CURPOS := PREVPOS (CURPOS );END ELSE BEGIN INC (XPOS );INC (FIRSTPOS );CURPOS :=
NEXTPOS (CURPOS );END ;END ;END ;VAR OOllO0l1I10l:INTEGER;OOIO:INTEGER;OIlOOO1I1I:BOOLEAN;OOII0I0lOOO1:BOOLEAN;
OIOI100IlI0:STRING ;BEGIN TVIEW.HANDLEEVENT (EVENT );CASE EVENT.WHAT  OF EVMOUSEDOWN :BEGIN IF (STATE AND SFSELECTED <> 0
)THEN BEGIN IF O10O11lIO100O (OOII0I0lOOO1 )THEN BEGIN REPEAT OIO101I1O1I (OOII0I0lOOO1 );DRAWVIEW ;UNTIL NOT MOUSEEVENT
(EVENT , EVMOUSEAUTO );END ELSE IF EVENT.DOUBLE THEN BEGIN SELECTALL (TRUE );END ELSE BEGIN OOllO0l1I10l := Ol1lIl0010 ;
REPEAT IF (EVENT.WHAT =EVMOUSEAUTO )THEN BEGIN IF O10O11lIO100O (OOII0I0lOOO1 )THEN OIO101I1O1I (OOII0I0lOOO1 );END ELSE
BEGIN CURPOS := Ol1lIl0010 ;XPOS := MASKTOEDITPOS (CURPOS );END ;IF (CURPOS < OOllO0l1I10l )THEN BEGIN SELSTART := CURPOS
;SELEND := OOllO0l1I10l ;END ELSE BEGIN SELSTART := OOllO0l1I10l ;SELEND := CURPOS ;END ;DRAWVIEW ;UNTIL NOT MOUSEEVENT
(EVENT , EVMOUSEMOVE + EVMOUSEAUTO );END ;END ;CLEAREVENT (EVENT );END ;EVKEYDOWN :BEGIN CASE CTRLTOARROW (EVENT.KEYCODE
) OF KBLEFT :BEGIN IF (XPOS > 1 )THEN BEGIN DEC (XPOS );CURPOS := PREVPOS (CURPOS );END ;END ;KBRIGHT :BEGIN IF (XPOS <=
LENGTH (DATA ^))THEN IF (XPOS <= MAXLEN )THEN BEGIN INC (XPOS );CURPOS := NEXTPOS (CURPOS );END ;END ;KBHOME :BEGIN XPOS
:= 1 ;CURPOS := HOMEPOS ;END ;KBEND :BEGIN XPOS := LENGTH (DATA ^);CURPOS := NEXTPOS (EDITTOMASKPOS (XPOS ));INC (XPOS );
END ;KBBACK :BEGIN IF (XPOS > 1 )THEN BEGIN DEC (XPOS );CURPOS := PREVPOS (CURPOS );DELETE (DATA ^, XPOS , 1 );IF
(FIRSTPOS > 1 )THEN DEC (FIRSTPOS );END ;END ;KBDEL :BEGIN IF (SELSTART =SELEND )THEN DELETE (DATA ^, XPOS , 1 )ELSE
DELETEMARKED ;END ;KBINS :BEGIN SETSTATE (SFCURSORINS , STATE AND SFCURSORINS =0 );END ;ELSE CASE EVENT.CHARCODE
 OF ' '.. #255:BEGIN CASE (MASK ^[ CURPOS ] ) OF DATEONLY :BEGIN OIlOOO1I1I := EVENT.CHARCODE IN DATEONLYSET ;END ;
HEXONLY :BEGIN OIlOOO1I1I := EVENT.CHARCODE IN HEXONLYSET ;END ;DIGITONLY :BEGIN OIlOOO1I1I := EVENT.CHARCODE IN
DIGITONLYSET ;END ;ANYCHAR :BEGIN OIlOOO1I1I := TRUE ;END ;FORCEUP :BEGIN EVENT.CHARCODE := UPCASE (EVENT.CHARCODE );
OIlOOO1I1I := TRUE ;END ;FORCELO :BEGIN EVENT.CHARCODE := OI1I1I10lIOI (EVENT.CHARCODE );OIlOOO1I1I := TRUE ;END ;
ALPHAONLY :BEGIN OIlOOO1I1I := EVENT.CHARCODE IN ALPHAONLYSET ;END ;UPPERALPHA :BEGIN EVENT.CHARCODE := UPCASE
(EVENT.CHARCODE );OIlOOO1I1I := EVENT.CHARCODE IN ALPHAONLYSET ;END ;LOWERALPHA :BEGIN EVENT.CHARCODE := OI1I1I10lIOI
(EVENT.CHARCODE );OIlOOO1I1I := EVENT.CHARCODE IN ALPHAONLYSET ;END ;NUMBERONLY :BEGIN OIlOOO1I1I := EVENT.CHARCODE IN
NUMBERONLYSET ;END ;ELSE OIlOOO1I1I := FALSE ;END ;IF OIlOOO1I1I THEN BEGIN INSERTCHAR (EVENT.CHARCODE );END ;END ;^Y
:BEGIN DATA ^:= '';XPOS := 1 ;CURPOS := HOMEPOS ;END ;ELSE EXIT ;END ;END ;SELSTART := 1 ;SELEND := 1 ;IF (FIRSTPOS >
CURPOS )THEN BEGIN IF (CURPOS =HOMEPOS )THEN FIRSTPOS := 1 ELSE FIRSTPOS := CURPOS ;END ;OOIO := CURPOS - SIZE.X + 2 ;IF
(FIRSTPOS < OOIO )THEN FIRSTPOS := OOIO ;DRAWVIEW ;CLEAREVENT (EVENT );END ;EVBROADCAST :BEGIN CASE EVENT.COMMAND
 OF CMSETID :BEGIN SETID (EVENT.INFOWORD );CLEAREVENT (EVENT );EVENT.INFOPTR := @ SELF ;END ;CMIDENTIFY :IF
(EVENT.INFOWORD =ID )THEN BEGIN CLEAREVENT (EVENT );EVENT.INFOPTR := @ SELF ;END ;END ;END ;END ;END ;
FUNCTION TBXEDITLINE.HOMEPOS :INTEGER ;BEGIN HOMEPOS := FIRST ;END ;PROCEDURE TBXEDITLINE.INSERTCHAR (CH:CHAR);BEGIN IF
(STATE AND SFCURSORINS <> 0 )THEN DELETE (DATA ^, XPOS , 1 )ELSE DELETEMARKED ;IF (LENGTH (DATA ^)< MAXLEN )THEN BEGIN IF
(FIRSTPOS > CURPOS )THEN FIRSTPOS := CURPOS ;INSERT (CH , DATA ^, XPOS );IF (XPOS <= MAXLEN )THEN BEGIN INC (XPOS );
CURPOS := NEXTPOS (CURPOS );END ;END ;END ;PROCEDURE TBXEDITLINE.LOCK ;BEGIN SETSTATE (SFDISABLED , TRUE );END ;
FUNCTION TBXEDITLINE.MASKTOEDITPOS (POS:INTEGER):INTEGER ;VAR OOIO:INTEGER;OIOO101OlII:INTEGER;BEGIN OIOO101OlII := 0 ;
FOR OOIO := 1 TO POS  DO IF (MASK ^[ OOIO ] IN EDITMASKCHARS )THEN INC (OIOO101OlII );MASKTOEDITPOS := OIOO101OlII ;
END ;PROCEDURE TBXEDITLINE.MERGE (VAR ST:STRING ;JUSTIFY:BOOLEAN);VAR OIlO,OIll:BYTE;OIOI100IlI0:STRING ;BEGIN OIll := 0
;FOR OIlO := 1 TO BYTE (MASK ^[ 0 ] ) DO BEGIN IF (MASK ^[ OIlO ] IN EDITMASKCHARS )THEN BEGIN IF (OIll < BYTE (DATA ^[ 0
] ))THEN BEGIN INC (OIll );IF ((EDITFLAGS AND DFHIDE )<> 0 )THEN ST [ OIlO ] := HIDECHAR ELSE ST [ OIlO ] := DATA ^[ OIll
] ;END ELSE BEGIN ST [ OIlO ] := PADCHAR ;END ;END ELSE BEGIN ST [ OIlO ] := MASK ^[ OIlO ] ;END ;END ;BYTE (ST [ 0 ] ):=
OIlO ;IF JUSTIFY THEN BEGIN IF ((EDITFLAGS AND DFRJUSTIFY )<> 0 )THEN BEGIN TRIMCH (ST , PADCHAR );LEFTPADCH (ST , MAXLEN
, PADCHAR );END ELSE IF ((EDITFLAGS AND DFLJUSTIFY )<> 0 )THEN BEGIN TRIMCH (ST , PADCHAR );PADCH (ST , MAXLEN , PADCHAR
);END ELSE IF ((EDITFLAGS AND DFTRIM )<> 0 )THEN TRIMCH (ST , PADCHAR )ELSE PADCH (ST , MAXLEN , PADCHAR );END ;END ;
FUNCTION TBXEDITLINE.NEXTPOS (POS:INTEGER):INTEGER ;VAR OOIO:INTEGER;BEGIN OOIO := POS + 1 ;WHILE (OOIO <= BYTE (MASK ^[
0 ] ))AND NOT (MASK ^[ OOIO ] IN EDITMASKCHARS ) DO INC (OOIO );IF (OOIO <= BYTE (MASK ^[ 0 ] )+ 1 )THEN NEXTPOS := OOIO
ELSE NEXTPOS := POS ;END ;FUNCTION TBXEDITLINE.PREVPOS (POS:INTEGER):INTEGER ;VAR OOIO:INTEGER;BEGIN OOIO := POS - 1 ;
WHILE (OOIO > 0 )AND NOT (MASK ^[ OOIO ] IN EDITMASKCHARS ) DO DEC (OOIO );IF (OOIO > 0 )THEN PREVPOS := OOIO ELSE
PREVPOS := POS ;END ;FUNCTION TBXEDITLINE.REMOVE (CONST ST:STRING ):STRING ;VAR OIlO,OIll:BYTE;OIOI100IlI0:STRING ;
BEGIN OIll := 0 ;FILLCHAR (OIOI100IlI0 , SIZEOF (OIOI100IlI0 ), 0 );FOR OIlO := 1 TO BYTE (ST [ 0 ] ) DO BEGIN IF (MASK
^[ OIlO ] IN EDITMASKCHARS )THEN BEGIN INC (OIll );OIOI100IlI0 [ OIll ] := ST [ OIlO ] ;END END ;BYTE (OIOI100IlI0 [ 0 ]
):= OIll ;REMOVE := OIOI100IlI0 ;END ;PROCEDURE TBXEDITLINE.SELECTALL (ENABLE:BOOLEAN);BEGIN CURPOS := HOMEPOS ;XPOS :=
MASKTOEDITPOS (CURPOS );FIRSTPOS := 1 ;SELSTART := 1 ;IF (ENABLE AND (BYTE (DATA ^[ 0 ] )> 0 ))THEN SELEND := BYTE (MASK
^[ 0 ] )ELSE SELEND := 1 ;DRAWVIEW ;END ;PROCEDURE TBXEDITLINE.SETDATA (VAR REC);BEGIN DATA ^:= FTRIMCH (REMOVE (STRING
(REC )), PADCHAR );SELECTALL (TRUE );END ;PROCEDURE TBXEDITLINE.SETEDITFLAG (AFLAG:WORD;ENABLE:BOOLEAN);BEGIN IF ENABLE
THEN EDITFLAGS := EDITFLAGS OR AFLAG ELSE EDITFLAGS := EDITFLAGS AND NOT AFLAG ;IF ENABLE AND (AFLAG AND (DFREQUIRED OR
DFDEFAULTS )<> 0 )THEN OPTIONS := OPTIONS OR OFVALIDATE ;END ;PROCEDURE TBXEDITLINE.SETID (AFIELDID:WORD);BEGIN ID :=
AFIELDID ;END ;PROCEDURE TBXEDITLINE.SETSTATE (ASTATE:WORD;ENABLE:BOOLEAN);BEGIN TVIEW.SETSTATE (ASTATE , ENABLE );IF
(ASTATE =SFSELECTED )OR ((ASTATE =SFACTIVE )AND (STATE AND SFSELECTED <> 0 ))THEN SELECTALL (ENABLE )ELSE IF (ASTATE AND
SFDISABLED <> 0 )THEN IF (LLABEL <> NIL )THEN LLABEL ^. SETSTATE (SFDISABLED , ENABLE );END ;PROCEDURE TBXEDITLINE.STORE
(VAR S:TSTREAM);BEGIN INHERITED STORE(S );S.WRITE (PADCHAR , SIZEOF (CHAR ));S.WRITE (XPOS , SIZEOF (BYTE ));S.WRITE
(FIRST , SIZEOF (BYTE ));S.WRITESTR (MASK );S.WRITE (ID , SIZEOF (BYTE ));PUTPEERVIEWPTR (S , LLABEL );S.WRITE (EDITFLAGS
, SIZEOF (WORD ));END ;PROCEDURE TBXEDITLINE.UNLOCK ;BEGIN SETSTATE (SFDISABLED , FALSE );END ;
FUNCTION TBXEDITLINE.VALID (COMMAND:WORD):BOOLEAN ;VAR O10lII00l:STRING ;BEGIN IF (COMMAND <> CMCANCEL )AND (COMMAND <>
CMVALID )AND ((EDITFLAGS AND DFREQUIRED )<> 0 )AND EMPTY THEN BEGIN O10lII00l := GETFIELDNAME + ^M +
'Field is required.';MESSAGE (OWNER , EVBROADCAST , CMFIELDERROR , @ O10lII00l );VALID := FALSE ;SELECT ;END ELSE VALID
:= INHERITED VALID(COMMAND );END ;CONSTRUCTOR TBXDATEEDIT.INIT (VAR BOUNDS:TRECT;ADATEPIC:TBXDATEST);VAR OO1O:TBXDATEST;
OIlO:BYTE;BEGIN OO1O := ADATEPIC ;FOR OIlO := 1 TO LENGTH (OO1O ) DO CASE OO1O [ OIlO ]  OF 'm', 'M', 'd', 'D', 'y',
'Y':OO1O [ OIlO ] := '@';END ;INHERITED INIT(BOUNDS , OO1O );DATEPIC := ADATEPIC ;DATE := NEW (PBXDATE , INIT (0 , 0 , 0
));END ;CONSTRUCTOR TBXDATEEDIT.LOAD (VAR S:TSTREAM);BEGIN INHERITED LOAD(S );S.READ (DATEPIC , SIZEOF (TBXDATEST ));
DATE := NEW (PBXDATE , LOAD (S ));END ;FUNCTION TBXDATEEDIT.DATASIZE :WORD ;BEGIN DATASIZE := SIZEOF (TBXDATEREC );END ;
PROCEDURE TBXDATEEDIT.GETDATA (VAR REC);BEGIN DATE ^. GETDATA (REC );END ;PROCEDURE TBXDATEEDIT.SETDATA (VAR REC);
BEGIN DATE ^. SETDATA (REC );DATA ^:= REMOVE (DATE ^. DATESTRING (DATEPIC ));SELECTALL (TRUE );END ;
PROCEDURE TBXDATEEDIT.STORE (VAR S:TSTREAM);BEGIN INHERITED STORE(S );S.WRITE (DATEPIC , SIZEOF (TBXDATEST ));DATE ^.
STORE (S );END ;FUNCTION TBXDATEEDIT.VALID (COMMAND:WORD):BOOLEAN ;VAR OI0l1lIl1OII:BOOLEAN;O1Ol0OlOO01I:BOOLEAN;
O110l10l:BOOLEAN;OO1O:TBXDATEST;O10lII00l:STRING ;BEGIN IF (COMMAND <> CMCANCEL )AND (COMMAND <> CMVALID )AND NOT EMPTY
THEN BEGIN VALID := TRUE ;MERGE (OO1O , FALSE );DATE ^. EXTRACTDATE (DATEPIC , OO1O );OI0l1lIl1OII := (POS ('d', DATEPIC
)<> 0 )OR (POS ('D', DATEPIC )<> 0 );O1Ol0OlOO01I := (POS ('m', DATEPIC )<> 0 )OR (POS ('M', DATEPIC )<> 0 );IF
(EDITFLAGS AND DFDEFAULTS <> 0 )THEN BEGIN O1Ol0OlOO01I := TRUE ;OI0l1lIl1OII := TRUE ;IF (DATE ^. YEAR =0 )OR (DATE ^.
DAY =0 )OR (DATE ^. MONTH =0 )THEN BEGIN IF (DATE ^. YEAR =0 )THEN DATE ^. YEAR := DEFAULTYEAR ;IF (DATE ^. DAY =0 )THEN
DATE ^. DAY := DEFAULTDAY ;IF (DATE ^. MONTH =0 )THEN DATE ^. MONTH := DEFAULTMONTH ;DATA ^:= REMOVE (DATE ^. DATESTRING
(DATEPIC ));DRAWVIEW ;END ;END ;IF (O1Ol0OlOO01I AND OI0l1lIl1OII )THEN O110l10l := DATE ^. VALID ELSE IF O1Ol0OlOO01I
THEN O110l10l := (DATE ^. MONTH > 0 )AND (DATE ^. MONTH < 13 )ELSE O110l10l := TRUE ;IF NOT O110l10l THEN BEGIN VALID :=
FALSE ;SELECT ;O10lII00l := GETFIELDNAME + ^M + 'Date is not valid.'+ ^M + 'Enter a date in '+ DATEPIC + ' format.';
MESSAGE (OWNER , EVBROADCAST , CMFIELDERROR , @ O10lII00l );END ;END ELSE VALID := INHERITED VALID(COMMAND );END ;
DESTRUCTOR TBXDATEEDIT.DONE ;BEGIN DISPOSE (DATE , DONE );INHERITED DONE;END ;PROCEDURE TBXNUMERICEDIT.HANDLEEVENT
(VAR EVENT:TEVENT);VAR OIlOOO1I1I:BOOLEAN;BEGIN IF (EVENT.WHAT =EVKEYDOWN )THEN BEGIN CASE EVENT.CHARCODE  OF ' '..
#255:BEGIN CASE (MASK ^[ CURPOS ] ) OF DIGITONLY :OIlOOO1I1I := (EVENT.CHARCODE IN DIGITONLYSET );NUMBERONLY :OIlOOO1I1I
:= (EVENT.CHARCODE IN NUMBERONLYSET );HEXONLY :OIlOOO1I1I := (EVENT.CHARCODE IN HEXONLYSET );ELSE OIlOOO1I1I := FALSE ;
END ;IF NOT OIlOOO1I1I THEN CLEAREVENT (EVENT )ELSE CASE EVENT.CHARCODE  OF '-', '$':BEGIN IF (BYTE (DATA ^[ 0 ] )> 0
)THEN BEGIN IF (DATA ^[ 1 ] <> EVENT.CHARCODE )AND (BYTE (DATA ^[ 0 ] )< MAXLEN )THEN BEGIN INSERT (EVENT.CHARCODE , DATA
^, 1 );CURPOS := NEXTPOS (CURPOS );END ELSE IF (DATA ^[ 1 ] =EVENT.CHARCODE )THEN BEGIN DELETE (DATA ^, 1 , 1 );CURPOS :=
PREVPOS (CURPOS );END ;XPOS := MASKTOEDITPOS (CURPOS );DRAWVIEW ;CLEAREVENT (EVENT );END ;END ;END ;END ;END ;END ;
INHERITED HANDLEEVENT(EVENT );END ;FUNCTION TBXNUMERICEDIT.OUTOFRANGEMSG :STRING ;BEGIN OUTOFRANGEMSG :=
'Entry is not in valid range';END ;FUNCTION TBXNUMERICEDIT.OUTOFRANGE :BOOLEAN ;BEGIN OUTOFRANGE := FALSE ;END ;
FUNCTION TBXNUMERICEDIT.VALID (COMMAND:WORD):BOOLEAN ;VAR O10lII00l:STRING ;BEGIN VALID := TRUE ;IF (COMMAND <> CMCANCEL
)AND (COMMAND <> CMVALID )AND OUTOFRANGE THEN BEGIN VALID := FALSE ;SELECT ;O10lII00l := GETFIELDNAME + ^M +
OUTOFRANGEMSG ;MESSAGE (OWNER , EVBROADCAST , CMFIELDERROR , @ O10lII00l );END ELSE VALID := INHERITED VALID(COMMAND );
END ;CONSTRUCTOR TBXLONGEDIT.INIT (VAR BOUNDS:TRECT;CONST AMASK:STRING ;AMIN:LONGINT;AMAX:LONGINT);
BEGIN INHERITED INIT(BOUNDS , AMASK );IF (AMIN <= AMAX )THEN BEGIN MIN := AMIN ;MAX := AMAX ;END ELSE BEGIN MIN := AMAX ;
MAX := AMIN ;END ;END ;CONSTRUCTOR TBXLONGEDIT.LOAD (VAR S:TSTREAM);BEGIN INHERITED LOAD(S );S.READ (MIN , SIZEOF
(LONGINT ));S.READ (MAX , SIZEOF (LONGINT ));END ;FUNCTION TBXLONGEDIT.DATASIZE :WORD ;BEGIN DATASIZE := SIZEOF (LONGINT
);END ;PROCEDURE TBXLONGEDIT.GETDATA (VAR REC);BEGIN IF (DATA ^='')OR (DATA ^='$')OR (DATA ^='-')THEN DATA ^:= '0';VAL
(DATA ^, LONGINT (REC ), ERRCODE );IF (ERRCODE <> 0 )THEN LONGINT (REC ):= 0 ;END ;FUNCTION TBXLONGEDIT.OUTOFRANGE
:BOOLEAN ;VAR OI1IO1O100Ol:LONGINT;BEGIN OUTOFRANGE := FALSE ;IF (MIN <> 0 )OR (MAX <> 0 )THEN BEGIN TBXLONGEDIT.GETDATA
(OI1IO1O100Ol );IF (ERRCODE =0 )THEN OUTOFRANGE := ((OI1IO1O100Ol < MIN )OR (OI1IO1O100Ol > MAX ));END ;END ;
FUNCTION TBXLONGEDIT.OUTOFRANGEMSG :STRING ;VAR Ol00II0OlO10,Ol00II00OI00:STRING [ 11 ] ;BEGIN STR (MIN , Ol00II0OlO10 );
STR (MAX , Ol00II00OI00 );TRIM (Ol00II0OlO10 );TRIM (Ol00II00OI00 );OUTOFRANGEMSG := 'Valid Range is '+ Ol00II0OlO10 +
' to '+ Ol00II00OI00 ;END ;PROCEDURE TBXLONGEDIT.SETDATA (VAR REC);BEGIN IF (MIN <> 0 )OR (MAX <> 0 )THEN IF (LONGINT
(REC )< MIN )THEN LONGINT (REC ):= MIN ELSE IF (LONGINT (REC )> MAX )THEN LONGINT (REC ):= MAX ;STR (LONGINT (REC ), DATA
^);TRIM (DATA ^);SELECTALL (TRUE );END ;PROCEDURE TBXLONGEDIT.STORE (VAR S:TSTREAM);BEGIN INHERITED STORE(S );S.WRITE
(MIN , SIZEOF (LONGINT ));S.WRITE (MAX , SIZEOF (LONGINT ));END ;FUNCTION TBXHEXEDIT.OUTOFRANGEMSG :STRING ;
VAR Ol00II0OlO10,Ol00II00OI00:STRING [ 16 ] ;BEGIN OUTOFRANGEMSG := 'Range is '+ HEXSTRING (MIN )+ ' to '+ HEXSTRING (MAX
);END ;PROCEDURE TBXHEXEDIT.SETDATA (VAR REC);VAR OO1O:STRING [ 9 ] ;BEGIN OO1O := HEXSTRING (LONGINT (REC ));
WHILE (BYTE (OO1O [ 0 ] )> MAXLEN )AND (OO1O [ 2 ] ='0') DO DELETE (OO1O , 2 , 1 );TRUNCATESTR (OO1O , MAXLEN );DATA ^:=
OO1O ;SELECTALL (TRUE );END ;CONSTRUCTOR TBXINTEGEREDIT.INIT (VAR BOUNDS:TRECT;CONST AMASK:STRING ;AMIN:INTEGER;
AMAX:INTEGER);BEGIN INHERITED INIT(BOUNDS , AMASK , AMIN , AMAX );END ;FUNCTION TBXINTEGEREDIT.DATASIZE :WORD ;
BEGIN DATASIZE := SIZEOF (INTEGER );END ;PROCEDURE TBXINTEGEREDIT.GETDATA (VAR REC);VAR OO01:LONGINT;
BEGIN TBXLONGEDIT.GETDATA (OO01 );INTEGER (REC ):= OO01 ;END ;PROCEDURE TBXINTEGEREDIT.SETDATA (VAR REC);
VAR OO01:LONGINT;BEGIN OO01 := INTEGER (REC );TBXLONGEDIT.SETDATA (OO01 );END ;CONSTRUCTOR TBXWORDEDIT.INIT
(VAR BOUNDS:TRECT;CONST AMASK:STRING ;AMIN:WORD;AMAX:WORD);BEGIN INHERITED INIT(BOUNDS , AMASK , AMIN , AMAX );END ;
FUNCTION TBXWORDEDIT.DATASIZE :WORD ;BEGIN DATASIZE := SIZEOF (WORD );END ;PROCEDURE TBXWORDEDIT.GETDATA (VAR REC);
VAR OO01:LONGINT;BEGIN TBXLONGEDIT.GETDATA (OO01 );WORD (REC ):= OO01 ;END ;PROCEDURE TBXWORDEDIT.SETDATA (VAR REC);
VAR OO01:LONGINT;BEGIN OO01 := WORD (REC );TBXLONGEDIT.SETDATA (OO01 );END ;CONSTRUCTOR TBXBYTEEDIT.INIT
(VAR BOUNDS:TRECT;CONST AMASK:STRING ;AMIN:BYTE;AMAX:BYTE);BEGIN TBXLONGEDIT.INIT (BOUNDS , AMASK , AMIN , AMAX );END ;
FUNCTION TBXBYTEEDIT.DATASIZE :WORD ;BEGIN DATASIZE := SIZEOF (BYTE );END ;PROCEDURE TBXBYTEEDIT.GETDATA (VAR REC);
VAR OO01:LONGINT;BEGIN TBXLONGEDIT.GETDATA (OO01 );BYTE (REC ):= OO01 ;END ;PROCEDURE TBXBYTEEDIT.SETDATA (VAR REC);
VAR OO01:LONGINT;BEGIN OO01 := BYTE (REC );TBXLONGEDIT.SETDATA (OO01 );END ;CONSTRUCTOR TBXFLOATEDIT.INIT
(VAR BOUNDS:TRECT;CONST AMASK:STRING );VAR OOIO:BYTE;OIlO:BYTE;OO1O:STRING ;BEGIN OO1O := AMASK ;OOIO := POS (DECIMALPT ,
OO1O );IF (OOIO <> 0 )THEN BEGIN OIlO := 0 ;REPEAT INC (OIlO );UNTIL (OO1O [ OIlO ] IN EDITMASKCHARS );OO1O [ OOIO ] :=
OO1O [ OIlO ] ;END ;INHERITED INIT(BOUNDS , OO1O );IF (OOIO <> 0 )THEN DP := LENGTH (OO1O )- OOIO ELSE DP := 0 ;END ;
CONSTRUCTOR TBXFLOATEDIT.LOAD (VAR S:TSTREAM);BEGIN INHERITED LOAD(S );S.READ (DP , SIZEOF (BYTE ));END ;
PROCEDURE TBXFLOATEDIT.HANDLEEVENT (VAR EVENT:TEVENT);VAR OOIO:BYTE;BEGIN CASE EVENT.WHAT  OF EVKEYDOWN
:BEGIN CASE CTRLTOARROW (EVENT.KEYCODE ) OF KBBACK :BEGIN IF (XPOS > 1 )THEN IF (DATA ^[ XPOS - 1 ] =DECIMALPT )THEN
CLEAREVENT (EVENT );END ;KBDEL :BEGIN IF (XPOS <= LENGTH (DATA ^))THEN IF (DATA ^[ XPOS ] =DECIMALPT )THEN CLEAREVENT
(EVENT );END ;ELSE CASE EVENT.CHARCODE  OF DECIMALPT :BEGIN IF (DP =0 )THEN BEGIN CLEAREVENT (EVENT );END ELSE IF (POS
(DECIMALPT , DATA ^)<> 0 )THEN BEGIN XPOS := POS (DECIMALPT , DATA ^);CURPOS := NEXTPOS (EDITTOMASKPOS (XPOS ));INC (XPOS
);CLEAREVENT (EVENT );DRAWVIEW ;END ELSE BEGIN INSERTCHAR (DECIMALPT );CLEAREVENT (EVENT );DRAWVIEW ;END ;END ;'0'..
'9':BEGIN IF (DP <> 0 )THEN BEGIN OOIO := POS (DECIMALPT , DATA ^);IF (OOIO <> 0 )THEN IF (XPOS > OOIO )THEN IF ((LENGTH
(DATA ^)- OOIO )=DP )THEN CLEAREVENT (EVENT );END ;END ;END ;END ;END ;END ;INHERITED HANDLEEVENT(EVENT );END ;
PROCEDURE TBXFLOATEDIT.STORE (VAR S:TSTREAM);BEGIN INHERITED STORE(S );S.WRITE (DP , SIZEOF (BYTE ));END ;{$IFOPT N+}
CONSTRUCTOR TBXDOUBLEEDIT.INIT (VAR BOUNDS:TRECT;CONST AMASK:STRING ;AMIN:DOUBLE;AMAX:DOUBLE);
BEGIN INHERITED INIT(BOUNDS , AMASK );IF (AMIN <= AMAX )THEN BEGIN MIN := AMIN ;MAX := AMAX ;END ELSE BEGIN MIN := AMAX ;
MAX := AMIN ;END ;END ;CONSTRUCTOR TBXDOUBLEEDIT.LOAD (VAR S:TSTREAM);BEGIN INHERITED LOAD(S );S.READ (MIN , SIZEOF
(DOUBLE ));S.READ (MAX , SIZEOF (DOUBLE ));END ;FUNCTION TBXDOUBLEEDIT.DATASIZE :WORD ;BEGIN DATASIZE := SIZEOF (DOUBLE
);END ;PROCEDURE TBXDOUBLEEDIT.GETDATA (VAR REC);BEGIN STRIP (DATA ^, [ '$'] );IF (DATA ^='')OR (DATA ^='-')THEN DATA ^:=
'0';VAL (DATA ^, DOUBLE (REC ), ERRCODE );IF (ERRCODE <> 0 )THEN DOUBLE (REC ):= 0.0 ;END ;
FUNCTION TBXDOUBLEEDIT.OUTOFRANGE :BOOLEAN ;VAR OI1IO1O100Ol:DOUBLE;BEGIN OUTOFRANGE := FALSE ;IF (MIN <> 0.0 )OR (MAX <>
0.0 )THEN BEGIN GETDATA (OI1IO1O100Ol );IF (ERRCODE =0 )THEN OUTOFRANGE := (OI1IO1O100Ol < MIN )OR (OI1IO1O100Ol > MAX );
END ;END ;FUNCTION TBXDOUBLEEDIT.OUTOFRANGEMSG :STRING ;VAR Ol00II0OlO10,Ol00II00OI00:STRING [ 20 ] ;OOII:BYTE;BEGIN IF
(DP > 0 )THEN OOII := 20 - DP - 1 ELSE OOII := 20 ;STR (MIN :OOII :DP , Ol00II0OlO10 );STR (MAX :OOII :DP , Ol00II00OI00
);TRIM (Ol00II0OlO10 );TRIM (Ol00II00OI00 );OUTOFRANGEMSG := 'Valid Range is '+ Ol00II0OlO10 + ' to '+ Ol00II00OI00 ;
END ;PROCEDURE TBXDOUBLEEDIT.SETDATA (VAR REC);VAR OOII:BYTE;BEGIN STRIP (DATA ^, [ '$'] );IF (DP > 0 )THEN OOII :=
MAXLEN - DP - 1 ELSE OOII := MAXLEN ;IF (MIN <> 0.0 )OR (MAX <> 0.0 )THEN IF (DOUBLE (REC )< MIN )THEN DOUBLE (REC ):=
MIN ELSE IF (DOUBLE (REC )> MAX )THEN DOUBLE (REC ):= MAX ;STR (DOUBLE (REC ):OOII :DP , DATA ^);TRIM (DATA ^);SELECTALL
(TRUE );END ;PROCEDURE TBXDOUBLEEDIT.STORE (VAR S:TSTREAM);BEGIN INHERITED STORE(S );S.WRITE (MIN , SIZEOF (DOUBLE ));
S.WRITE (MAX , SIZEOF (DOUBLE ));END ;{$ENDIF} CONSTRUCTOR TBXREALEDIT.INIT (VAR BOUNDS:TRECT;CONST AMASK:STRING ;
AMIN:REAL;AMAX:REAL);BEGIN INHERITED INIT(BOUNDS , AMASK );IF (AMIN <= AMAX )THEN BEGIN MIN := AMIN ;MAX := AMAX ;
END ELSE BEGIN MIN := AMAX ;MAX := AMIN ;END ;END ;CONSTRUCTOR TBXREALEDIT.LOAD (VAR S:TSTREAM);BEGIN INHERITED LOAD(S );
S.READ (MIN , SIZEOF (REAL ));S.READ (MAX , SIZEOF (REAL ));END ;FUNCTION TBXREALEDIT.DATASIZE :WORD ;BEGIN DATASIZE :=
SIZEOF (REAL );END ;PROCEDURE TBXREALEDIT.GETDATA (VAR REC);BEGIN STRIP (DATA ^, [ '$'] );IF (DATA ^='')OR (DATA
^='-')THEN DATA ^:= '0';VAL (DATA ^, REAL (REC ), ERRCODE );IF (ERRCODE <> 0 )THEN REAL (REC ):= 0.0 ;END ;
FUNCTION TBXREALEDIT.OUTOFRANGE :BOOLEAN ;VAR OI1IO1O100Ol:REAL;BEGIN OUTOFRANGE := FALSE ;IF (MIN <> 0.0 )OR (MAX <> 0.0
)THEN BEGIN TBXREALEDIT.GETDATA (OI1IO1O100Ol );IF (ERRCODE =0 )THEN OUTOFRANGE := (OI1IO1O100Ol < MIN )OR (OI1IO1O100Ol
> MAX );END ;END ;FUNCTION TBXREALEDIT.OUTOFRANGEMSG :STRING ;VAR Ol00II0OlO10,Ol00II00OI00:STRING [ 20 ] ;OOII:BYTE;
BEGIN IF (DP > 0 )THEN OOII := 20 - DP - 1 ELSE OOII := 20 ;STR (MIN :OOII :DP , Ol00II0OlO10 );STR (MAX :OOII :DP ,
Ol00II00OI00 );TRIM (Ol00II0OlO10 );TRIM (Ol00II00OI00 );OUTOFRANGEMSG := 'Valid Range is '+ Ol00II0OlO10 + ' to '+
Ol00II00OI00 ;END ;PROCEDURE TBXREALEDIT.SETDATA (VAR REC);VAR OOII:BYTE;BEGIN STRIP (DATA ^, [ '$'] );IF (DP > 0 )THEN
OOII := MAXLEN - DP - 1 ELSE OOII := MAXLEN ;IF (MIN <> 0.0 )OR (MAX <> 0.0 )THEN IF (REAL (REC )< MIN )THEN REAL (REC
):= MIN ELSE IF (REAL (REC )> MAX )THEN REAL (REC ):= MAX ;STR (REAL (REC ):OOII :DP , DATA ^);TRIM (DATA ^);SELECTALL
(TRUE );END ;PROCEDURE TBXREALEDIT.STORE (VAR S:TSTREAM);BEGIN INHERITED STORE(S );S.WRITE (MIN , SIZEOF (REAL ));
S.WRITE (MAX , SIZEOF (REAL ));END ;CONSTRUCTOR TBXCHECKBOXES.INIT (VAR BOUNDS:TRECT;ASTRINGS:PSITEM);
BEGIN INHERITED INIT(BOUNDS , ASTRINGS );LLABEL := NIL ;ID := 0 ;EDITFLAGS := 0 ;EVENTMASK := EVENTMASK OR EVBROADCAST ;
END ;CONSTRUCTOR TBXCHECKBOXES.LOAD (VAR S:TSTREAM);BEGIN INHERITED LOAD(S );S.READ (ID , SIZEOF (BYTE ));GETPEERVIEWPTR
(S , LLABEL );S.READ (EDITFLAGS , SIZEOF (WORD ));END ;PROCEDURE TBXCHECKBOXES.ADDLABEL (ALABEL:PLABEL);BEGIN LLABEL :=
ALABEL ;END ;FUNCTION TBXCHECKBOXES.EMPTY :BOOLEAN ;BEGIN EMPTY := (VALUE =0 );END ;FUNCTION TBXCHECKBOXES.GETFIELDNAME
:STRING ;VAR OI111IlIOOl0:STRING ;BEGIN IF (LLABEL <> NIL )THEN BEGIN OI111IlIOOl0 := PLABEL (LLABEL )^. TEXT ^;STRIP
(OI111IlIOOl0 , [ '~'] );END ELSE OI111IlIOOl0 := '';GETFIELDNAME := OI111IlIOOl0 ;END ;FUNCTION TBXCHECKBOXES.GETID
:WORD ;BEGIN GETID := ID ;END ;PROCEDURE TBXCHECKBOXES.HANDLEEVENT (VAR EVENT:TEVENT);BEGIN INHERITED HANDLEEVENT(EVENT
);CASE EVENT.WHAT  OF EVBROADCAST :BEGIN CASE EVENT.COMMAND  OF CMSETID :BEGIN SETID (EVENT.INFOWORD );CLEAREVENT (EVENT
);EVENT.INFOPTR := @ SELF ;END ;CMIDENTIFY :IF (EVENT.INFOWORD =ID )THEN BEGIN CLEAREVENT (EVENT );EVENT.INFOPTR := @
SELF ;END ;END ;END ;END ;END ;PROCEDURE TBXCHECKBOXES.LOCK ;BEGIN SETSTATE (SFDISABLED , TRUE );END ;
PROCEDURE TBXCHECKBOXES.SETEDITFLAG (AFLAG:WORD;ENABLE:BOOLEAN);BEGIN IF ENABLE THEN EDITFLAGS := EDITFLAGS OR AFLAG ELSE
EDITFLAGS := EDITFLAGS AND NOT AFLAG ;IF ENABLE AND (AFLAG AND DFREQUIRED <> 0 )THEN OPTIONS := OPTIONS OR OFVALIDATE ;
END ;PROCEDURE TBXCHECKBOXES.SETID (AFIELDID:WORD);BEGIN ID := AFIELDID ;END ;PROCEDURE TBXCHECKBOXES.SETSTATE
(ASTATE:WORD;ENABLE:BOOLEAN);BEGIN INHERITED SETSTATE(ASTATE , ENABLE );IF (ASTATE AND SFDISABLED <> 0 )THEN IF (LLABEL
<> NIL )THEN LLABEL ^. SETSTATE (SFDISABLED , ENABLE );END ;PROCEDURE TBXCHECKBOXES.STORE (VAR S:TSTREAM);
BEGIN INHERITED STORE(S );S.WRITE (ID , SIZEOF (BYTE ));PUTPEERVIEWPTR (S , LLABEL );S.WRITE (EDITFLAGS , SIZEOF (WORD
));END ;PROCEDURE TBXCHECKBOXES.UNLOCK ;BEGIN SETSTATE (SFDISABLED , FALSE );END ;FUNCTION TBXCHECKBOXES.VALID
(COMMAND:WORD):BOOLEAN ;VAR O10lII00l:STRING ;BEGIN IF (COMMAND <> CMCANCEL )AND (COMMAND <> CMVALID )AND ((EDITFLAGS AND
DFREQUIRED )<> 0 )AND EMPTY THEN BEGIN O10lII00l := GETFIELDNAME + ^M + 'Field is required.';MESSAGE (OWNER , EVBROADCAST
, CMFIELDERROR , @ O10lII00l );VALID := FALSE ;SELECT ;END ELSE VALID := INHERITED VALID(COMMAND );END ;
CONSTRUCTOR TBXRADIOBUTTONS.INIT (VAR BOUNDS:TRECT;ASTRINGS:PSITEM);BEGIN INHERITED INIT(BOUNDS , ASTRINGS );LLABEL :=
NIL ;ID := 0 ;EDITFLAGS := 0 ;EVENTMASK := EVENTMASK OR EVBROADCAST ;END ;CONSTRUCTOR TBXRADIOBUTTONS.LOAD
(VAR S:TSTREAM);BEGIN INHERITED LOAD(S );S.READ (ID , SIZEOF (BYTE ));GETPEERVIEWPTR (S , LLABEL );S.READ (EDITFLAGS ,
SIZEOF (WORD ));END ;PROCEDURE TBXRADIOBUTTONS.ADDLABEL (ALABEL:PLABEL);BEGIN LLABEL := ALABEL ;END ;
FUNCTION TBXRADIOBUTTONS.GETFIELDNAME :STRING ;VAR OI111IlIOOl0:STRING ;BEGIN IF (LLABEL <> NIL )THEN BEGIN OI111IlIOOl0
:= PLABEL (LLABEL )^. TEXT ^;STRIP (OI111IlIOOl0 , [ '~'] );END ELSE OI111IlIOOl0 := '';GETFIELDNAME := OI111IlIOOl0 ;
END ;FUNCTION TBXRADIOBUTTONS.GETID :WORD ;BEGIN GETID := ID ;END ;PROCEDURE TBXRADIOBUTTONS.HANDLEEVENT
(VAR EVENT:TEVENT);BEGIN INHERITED HANDLEEVENT(EVENT );CASE EVENT.WHAT  OF EVBROADCAST :BEGIN CASE EVENT.COMMAND
 OF CMSETID :BEGIN SETID (EVENT.INFOWORD );CLEAREVENT (EVENT );EVENT.INFOPTR := @ SELF ;END ;CMIDENTIFY :IF
(EVENT.INFOWORD =ID )THEN BEGIN CLEAREVENT (EVENT );EVENT.INFOPTR := @ SELF ;END ;END ;END ;END ;END ;
PROCEDURE TBXRADIOBUTTONS.LOCK ;BEGIN SETSTATE (SFDISABLED , TRUE );END ;PROCEDURE TBXRADIOBUTTONS.SETEDITFLAG
(AFLAG:WORD;ENABLE:BOOLEAN);BEGIN IF ENABLE THEN EDITFLAGS := EDITFLAGS OR AFLAG ELSE EDITFLAGS := EDITFLAGS AND NOT
AFLAG ;END ;PROCEDURE TBXRADIOBUTTONS.SETID (AFIELDID:WORD);BEGIN ID := AFIELDID ;END ;
PROCEDURE TBXRADIOBUTTONS.SETSTATE (ASTATE:WORD;ENABLE:BOOLEAN);BEGIN INHERITED SETSTATE(ASTATE , ENABLE );IF (ASTATE AND
SFDISABLED <> 0 )THEN IF (LLABEL <> NIL )THEN LLABEL ^. SETSTATE (SFDISABLED , ENABLE );END ;
PROCEDURE TBXRADIOBUTTONS.STORE (VAR S:TSTREAM);BEGIN INHERITED STORE(S );S.WRITE (ID , SIZEOF (BYTE ));PUTPEERVIEWPTR (S
, LLABEL );S.WRITE (EDITFLAGS , SIZEOF (WORD ));END ;PROCEDURE TBXRADIOBUTTONS.UNLOCK ;BEGIN SETSTATE (SFDISABLED , FALSE
);END ;CONSTRUCTOR TBXSLIDER.INIT (VAR BOUNDS:TRECT;AMIN:INTEGER;AMAX:INTEGER;CONST AMINLABEL:STRING ;
CONST AMAXLABEL:STRING );VAR OO1I:TRECT;OO10:PVIEW;BEGIN INHERITED INIT(BOUNDS );EVENTMASK := EVENTMASK OR EVBROADCAST ;
OPTIONS := OPTIONS OR OFFIRSTCLICK ;LLABEL := NIL ;ID := 0 ;EDITFLAGS := 0 ;OO1I.ASSIGN (0 , 0 , SIZE.X , SIZE.Y );OO10
:= NEW (PSTATICTEXT , INIT (OO1I , ' '));IF (APPLICATION ^. VALIDVIEW (OO10 )=NIL )THEN FAIL ;INSERT (OO10 );IF
(AMINLABEL <> '')OR (AMAXLABEL <> '')THEN OO1I.ASSIGN (0 , 1 , SIZE.X , SIZE.Y )ELSE OO1I.ASSIGN (0 , 0 , SIZE.X , SIZE.Y
);SCROLLBAR := NEW (PSCROLLBAR , INIT (OO1I ));SCROLLBAR ^. OPTIONS := SCROLLBAR ^. OPTIONS OR OFSELECTABLE ;IF
(APPLICATION ^. VALIDVIEW (SCROLLBAR )=NIL )THEN FAIL ;INSERT (SCROLLBAR );SCROLLBAR ^. SETRANGE (AMIN , AMAX );IF
(AMINLABEL <> '')THEN BEGIN OO1I.ASSIGN (0 , 0 , LENGTH (AMINLABEL ), 1 );OO10 := NEW (PSTATICTEXT , INIT (OO1I ,
AMINLABEL ));IF (APPLICATION ^. VALIDVIEW (OO10 )=NIL )THEN FAIL ;INSERT (OO10 );END ;IF (AMAXLABEL <> '')THEN
BEGIN OO1I.ASSIGN (SIZE.X - LENGTH (AMAXLABEL ), 0 , SIZE.X , 1 );OO10 := NEW (PSTATICTEXT , INIT (OO1I , AMAXLABEL ));
IF (APPLICATION ^. VALIDVIEW (OO10 )=NIL )THEN FAIL ;INSERT (OO10 );END ;END ;CONSTRUCTOR TBXSLIDER.LOAD (VAR S:TSTREAM);
BEGIN INHERITED LOAD(S );GETSUBVIEWPTR (S , SCROLLBAR );S.READ (ID , SIZEOF (BYTE ));GETPEERVIEWPTR (S , LLABEL );S.READ
(EDITFLAGS , SIZEOF (WORD ));END ;PROCEDURE TBXSLIDER.ADDLABEL (ALABEL:PLABEL);BEGIN LLABEL := ALABEL ;END ;
PROCEDURE TBXSLIDER.GETDATA (VAR REC);BEGIN INTEGER (REC ):= SCROLLBAR ^. VALUE ;END ;FUNCTION TBXSLIDER.GETFIELDNAME
:STRING ;VAR OI111IlIOOl0:STRING ;BEGIN IF (LLABEL <> NIL )THEN BEGIN OI111IlIOOl0 := PLABEL (LLABEL )^. TEXT ^;STRIP
(OI111IlIOOl0 , [ '~'] );END ELSE OI111IlIOOl0 := '';GETFIELDNAME := OI111IlIOOl0 ;END ;FUNCTION TBXSLIDER.GETID :WORD ;
BEGIN GETID := ID ;END ;PROCEDURE TBXSLIDER.HANDLEEVENT (VAR EVENT:TEVENT);FUNCTION OI1IIO0lOOO1 (OO10:PVIEW):BOOLEAN ;
FAR ;BEGIN OI1IIO0lOOO1 := (OO10 ^. STATE AND SFVISIBLE <> 0 )AND OO10 ^. MOUSEINVIEW (EVENT.WHERE );END ;BEGIN IF
(EVENT.WHAT =EVBROADCAST )THEN BEGIN CASE EVENT.COMMAND  OF CMSETID :BEGIN SETID (EVENT.INFOWORD );CLEAREVENT (EVENT );
EVENT.INFOPTR := @ SELF ;END ;CMIDENTIFY :IF (EVENT.INFOWORD =ID )THEN BEGIN CLEAREVENT (EVENT );EVENT.INFOPTR := @ SELF
;END ;END ;END ELSE IF (EVENT.WHAT AND POSITIONALEVENTS <> 0 )THEN BEGIN IF (FIRSTTHAT (@ OI1IIO0lOOO1 )<> LAST )THEN
INHERITED HANDLEEVENT(EVENT )ELSE CLEAREVENT (EVENT );END ELSE INHERITED HANDLEEVENT(EVENT )END ;
PROCEDURE TBXSLIDER.LOCK ;BEGIN SETSTATE (SFDISABLED , TRUE );END ;PROCEDURE TBXSLIDER.SETDATA (VAR REC);BEGIN IF
(INTEGER (REC )<> SCROLLBAR ^. VALUE )THEN SCROLLBAR ^. SETVALUE (INTEGER (REC ));END ;PROCEDURE TBXSLIDER.SETEDITFLAG
(AFLAG:WORD;ENABLE:BOOLEAN);BEGIN IF ENABLE THEN EDITFLAGS := EDITFLAGS OR AFLAG ELSE EDITFLAGS := EDITFLAGS AND NOT
AFLAG ;END ;PROCEDURE TBXSLIDER.SETID (AFIELDID:WORD);BEGIN ID := AFIELDID ;END ;PROCEDURE TBXSLIDER.SETSTATE
(ASTATE:WORD;ENABLE:BOOLEAN);BEGIN INHERITED SETSTATE(ASTATE , ENABLE );IF (ASTATE AND SFDISABLED <> 0 )THEN
BEGIN SCROLLBAR ^. SETSTATE (SFDISABLED , ENABLE );IF (LLABEL <> NIL )THEN LLABEL ^. SETSTATE (SFDISABLED , ENABLE );
END ;END ;PROCEDURE TBXSLIDER.STORE (VAR S:TSTREAM);BEGIN INHERITED STORE(S );PUTSUBVIEWPTR (S , SCROLLBAR );S.WRITE (ID
, SIZEOF (BYTE ));PUTPEERVIEWPTR (S , LLABEL );S.WRITE (EDITFLAGS , SIZEOF (WORD ));END ;PROCEDURE TBXSLIDER.UNLOCK ;
BEGIN SETSTATE (SFDISABLED , FALSE );END ;CONSTRUCTOR TBXSPINBAR.INIT (VAR BOUNDS:TRECT);
CONST O10OO0I0Ill1I:TBXSPINCHARS=(#30, #31);O10OO0I0IlO0I:TBXSPINCHARS=(#17, #16);BEGIN INHERITED INIT(BOUNDS );OPTIONS
:= OPTIONS OR OFFIRSTCLICK ;IF SIZE.X =1 THEN CHARS := O10OO0I0Ill1I ELSE CHARS := O10OO0I0IlO0I ;END ;
CONSTRUCTOR TBXSPINBAR.LOAD (VAR S:TSTREAM);BEGIN INHERITED LOAD(S );S.READ (CHARS , 2 * SIZEOF (CHAR ));END ;
PROCEDURE TBXSPINBAR.DRAW ;VAR OIO1:TDRAWBUFFER;BEGIN MOVECHAR (OIO1 [ 0 ] , CHARS [ 1 ] , GETCOLOR (2 ), 1 );MOVECHAR
(OIO1 [ 1 ] , CHARS [ 2 ] , GETCOLOR (2 ), 1 );WRITEBUF (0 , 0 , SIZE.X , SIZE.Y , OIO1 );END ;
PROCEDURE TBXSPINBAR.HANDLEEVENT (VAR EVENT:TEVENT);VAR OI1I1O1lll10:TPOINT;OOIO:INTEGER;BEGIN TVIEW.HANDLEEVENT (EVENT
);CASE EVENT.WHAT  OF EVMOUSEDOWN :BEGIN SPINEDIT ^. GETDATA (OOIO );IF (OOIO < MIN )THEN OOIO := MIN ELSE IF (OOIO > MAX
)THEN OOIO := MAX ;IF (VALUE <> OOIO )THEN VALUE := OOIO ;REPEAT MAKELOCAL (EVENT.WHERE , OI1I1O1lll10 );OOIO := 0 ;IF
(SIZE.X =1 )THEN BEGIN IF (OI1I1O1lll10.Y =0 )THEN OOIO := ARSTEP ELSE IF (OI1I1O1lll10.Y =1 )THEN OOIO := - ARSTEP ;
END ELSE IF (SIZE.Y =1 )THEN BEGIN IF (OI1I1O1lll10.X =1 )THEN OOIO := ARSTEP ELSE IF (OI1I1O1lll10.X =0 )THEN OOIO := -
ARSTEP ;END ;IF (OOIO <> 0 )THEN SETVALUE (VALUE + OOIO );UNTIL NOT MOUSEEVENT (EVENT , EVMOUSEAUTO )OR NOT MOUSEINVIEW
(EVENT.WHERE );CLEAREVENT (EVENT );END ;END ;END ;PROCEDURE TBXSPINBAR.STORE (VAR S:TSTREAM);BEGIN INHERITED STORE(S );
S.WRITE (CHARS , 2 * SIZEOF (CHAR ));END ;CONSTRUCTOR TBXSPINEDIT.INIT (VAR BOUNDS:TRECT;CONST AMASK:STRING ;
ASPINBAR:PBXSPINBAR);BEGIN IF (ASPINBAR =NIL )THEN FAIL ;INHERITED INIT(BOUNDS , AMASK , ASPINBAR ^. MIN , ASPINBAR ^.
MAX );SPINBAR := ASPINBAR ;EVENTMASK := EVENTMASK OR EVBROADCAST ;OPTIONS := OPTIONS OR OFVALIDATE ;
INHERITED SETDATA(SPINBAR ^. VALUE );SPINBAR ^. SPINEDIT := @ SELF ;END ;CONSTRUCTOR TBXSPINEDIT.LOAD (VAR S:TSTREAM);
BEGIN INHERITED LOAD(S );GETPEERVIEWPTR (S , SPINBAR );END ;PROCEDURE TBXSPINEDIT.HANDLEEVENT (VAR EVENT:TEVENT);
BEGIN IF (EVENT.WHAT =EVBROADCAST )THEN BEGIN CASE EVENT.COMMAND  OF CMSCROLLBARCHANGED :IF (EVENT.INFOPTR =SPINBAR )THEN
SETDATA (SPINBAR ^. VALUE );END ;END ;INHERITED HANDLEEVENT(EVENT );END ;PROCEDURE TBXSPINEDIT.SETDATA (VAR REC);
VAR OOIO:INTEGER;BEGIN GETDATA (OOIO );IF (INTEGER (REC )<> OOIO )THEN BEGIN INHERITED SETDATA(REC );SPINBAR ^. SETVALUE
(INTEGER (REC ));END ;END ;PROCEDURE TBXSPINEDIT.SETSTATE (ASTATE:WORD;ENABLE:BOOLEAN);BEGIN INHERITED SETSTATE(ASTATE ,
ENABLE );IF (ASTATE AND SFDISABLED <> 0 )THEN SPINBAR ^. SETSTATE (SFDISABLED , ENABLE );END ;
PROCEDURE TBXSPINEDIT.STORE (VAR S:TSTREAM);BEGIN INHERITED STORE(S );PUTPEERVIEWPTR (S , SPINBAR );END ;
FUNCTION TBXSPINEDIT.VALID (COMMAND:WORD):BOOLEAN ;VAR OOIO:INTEGER;BEGIN GETDATA (OOIO );IF (OOIO < SPINBAR ^. MIN )THEN
BEGIN OOIO := SPINBAR ^. MIN ;VALID := FALSE ;END ELSE IF (OOIO > SPINBAR ^. MAX )THEN BEGIN OOIO := SPINBAR ^. MAX ;
VALID := FALSE ;END ELSE BEGIN VALID := TRUE ;END ;SETDATA (OOIO );END ;CONSTRUCTOR TBXENTRYDIALOG.INIT
(VAR BOUNDS:TRECT;ATITLE:TTITLESTR);BEGIN INHERITED INIT(BOUNDS , ATITLE );EVENTMASK := EVENTMASK OR EVBROADCAST ;NEXTID
:= 0 ;END ;CONSTRUCTOR TBXENTRYDIALOG.LOAD (VAR S:TSTREAM);BEGIN INHERITED LOAD(S );S.READ (NEXTID , SIZEOF (WORD ));
END ;FUNCTION TBXENTRYDIALOG.FINDFIELD (ID:WORD):POINTER ;FUNCTION OII0IIlOIl (OO10:PVIEW):BOOLEAN ;FAR ;
VAR OIOO0l010lO:TEVENT;BEGIN OIOO0l010lO.WHAT := EVBROADCAST ;OIOO0l010lO.COMMAND := CMIDENTIFY ;OIOO0l010lO.INFOWORD :=
ID ;OO10 ^. HANDLEEVENT (OIOO0l010lO );OII0IIlOIl := (OIOO0l010lO.WHAT =EVNOTHING );END ;BEGIN FINDFIELD := FIRSTTHAT (@
OII0IIlOIl );END ;PROCEDURE TBXENTRYDIALOG.HANDLEEVENT (VAR EVENT:TEVENT);BEGIN INHERITED HANDLEEVENT(EVENT );IF
(EVENT.WHAT =EVBROADCAST )THEN IF (EVENT.COMMAND =CMFIELDERROR )THEN BEGIN MESSAGEBOX (PSTRING (EVENT.INFOPTR )^, NIL ,
MFERROR + MFOKBUTTON );CLEAREVENT (EVENT );END ;END ;PROCEDURE TBXENTRYDIALOG.INSERT (P:PVIEW);VAR OIOO0l010lO:TEVENT;
BEGIN INHERITED INSERT(P );CLEAREVENT (OIOO0l010lO );OIOO0l010lO.WHAT := EVBROADCAST ;OIOO0l010lO.COMMAND := CMSETID ;
OIOO0l010lO.INFOWORD := NEXTID + 1 ;P ^. HANDLEEVENT (OIOO0l010lO );IF (OIOO0l010lO.INFOPTR <> NIL )THEN INC (NEXTID );
END ;PROCEDURE TBXENTRYDIALOG.LOCKFIELD (ID:WORD;ENABLE:BOOLEAN);VAR OO10:PVIEW;BEGIN OO10 := FINDFIELD (ID );IF (OO10 <>
NIL )THEN OO10 ^. SETSTATE (SFDISABLED , ENABLE );END ;PROCEDURE TBXENTRYDIALOG.STORE (VAR S:TSTREAM);
BEGIN INHERITED STORE(S );S.WRITE (NEXTID , SIZEOF (WORD ));END ;PROCEDURE REGISTERTVINPUT ;BEGIN REGISTERTYPE
(RBXEDITLINE );REGISTERTYPE (RBXDATEEDIT );REGISTERTYPE (RBXLONGEDIT );REGISTERTYPE (RBXHEXEDIT );REGISTERTYPE
(RBXINTEGEREDIT );REGISTERTYPE (RBXWORDEDIT );REGISTERTYPE (RBXBYTEEDIT );{$IFOPT N+} REGISTERTYPE (RBXDOUBLEEDIT );
{$ENDIF} REGISTERTYPE (RBXREALEDIT );REGISTERTYPE (RBXRADIOBUTTONS );REGISTERTYPE (RBXCHECKBOXES );REGISTERTYPE
(RBXENTRYDIALOG );REGISTERTYPE (RBXSLIDER );REGISTERTYPE (RBXSPINBAR );REGISTERTYPE (RBXSPINEDIT );END ;END .
