{*
*
*   Copyright (c) 1992,93 by Richard W. Hansen
*
*   This source code will compile.
*   Full source code available to registered users.
*
*}
(* This file was mangled by Mangler 1.10 (c) Copyright 1993 by Berend de Boer *)
 UNIT TVSCROLL ;{$B+} {$X+} {$V-} {$I TVDEFS.INC} INTERFACE USES TVCONST , TVVIEWS , OBJECTS , DIALOGS , DRIVERS ,
VIEWS ;CONST GFSCROLLXY =$80 ;SCVSCROLL =OFVSCROLLBAR ;SCHSCROLL =OFHSCROLLBAR ;CSCROLLINPUTLINE =#1#6#7#1;
TYPE PBXSCROLLGROUP =^TBXSCROLLGROUP ;TBXSCROLLGROUP =OBJECT (TGROUP)VSCROLLBAR :PSCROLLBAR ;HSCROLLBAR :PSCROLLBAR ;
OLDPOS :TPOINT ;AUTOPOS :BOOLEAN ;CONSTRUCTOR INIT (VAR BOUNDS :TRECT ;AHSCROLLBAR :PSCROLLBAR ;
AVSCROLLBAR :PSCROLLBAR );CONSTRUCTOR LOAD (VAR S :TSTREAM );PROCEDURE HANDLEEVENT (VAR EVENT :TEVENT );VIRTUAL;
PROCEDURE STORE (VAR S :TSTREAM );END ;PBXSCROLLDIALOG =^TBXSCROLLDIALOG ;
TBXSCROLLDIALOG =OBJECT (TDIALOG)LIMIT :TPOINT ;VSCROLLBAR :PSCROLLBAR ;HSCROLLBAR :PSCROLLBAR ;
INTERIOR :PBXSCROLLGROUP ;CONSTRUCTOR INIT (VAR BOUNDS :TRECT ;ATITLE :STRING ;OFFLAG :WORD );CONSTRUCTOR LOAD
(VAR S :TSTREAM );PROCEDURE AUTOPOSITION (ENABLE :BOOLEAN );FUNCTION INITBACKGROUND :PVIEW ;VIRTUAL;
PROCEDURE INSERTTOSCROLL (P :PVIEW );PROCEDURE SETLIMIT (X ,Y:INTEGER );PROCEDURE STORE (VAR S :TSTREAM );END ;
PBXSCROLLVIEW =^TBXSCROLLVIEW ;TBXSCROLLVIEW =OBJECT (TVIEW)CONSTRUCTOR INIT (VAR BOUNDS :TRECT );PROCEDURE HANDLEEVENT
(VAR EVENT :TEVENT );VIRTUAL;PROCEDURE SETSTATE (ASTATE :WORD ;ENABLE :BOOLEAN );VIRTUAL;END ;
PBXSCROLLINPUTLINE =^TBXSCROLLINPUTLINE ;TBXSCROLLINPUTLINE =OBJECT (TINPUTLINE)FUNCTION GETPALETTE :PPALETTE ;VIRTUAL;
END ;PBXSCROLLWINDOW =^TBXSCROLLWINDOW ;TBXSCROLLWINDOW =OBJECT (TBXWINDOW)LIMIT :TPOINT ;VSCROLLBAR :PSCROLLBAR ;
HSCROLLBAR :PSCROLLBAR ;INTERIOR :PBXSCROLLGROUP ;CONSTRUCTOR INIT (VAR BOUNDS :TRECT ;ATITLE :STRING ;ANUMBER :WORD ;
OFFLAG :WORD );CONSTRUCTOR LOAD (VAR S :TSTREAM );PROCEDURE AUTOPOSITION (ENABLE :BOOLEAN );PROCEDURE CHANGEBOUNDS
(VAR BOUNDS :TRECT );VIRTUAL;FUNCTION INITBACKGROUND :PVIEW ;VIRTUAL;PROCEDURE INSERTTOSCROLL (P :PVIEW );
PROCEDURE SETLIMIT (X ,Y:INTEGER );PROCEDURE STORE (VAR S :TSTREAM );END ;PROCEDURE REGISTERTVSCROLL ;
CONST RBXSCROLLGROUP :TSTREAMREC =(OBJTYPE :5350 ;VMTLINK :OFS (TYPEOF (TBXSCROLLGROUP )^);LOAD :@ TBXSCROLLGROUP .
LOAD ;STORE :@ TBXSCROLLGROUP . STORE );CONST RBXSCROLLDIALOG :TSTREAMREC =(OBJTYPE :5351 ;
VMTLINK :OFS (TYPEOF (TBXSCROLLDIALOG )^);LOAD :@ TBXSCROLLDIALOG . LOAD ;STORE :@ TBXSCROLLDIALOG . STORE );
CONST RBXSCROLLINPUTLINE :TSTREAMREC =(OBJTYPE :5352 ;VMTLINK :OFS (TYPEOF (TBXSCROLLINPUTLINE )^);LOAD :@
TBXSCROLLINPUTLINE . LOAD ;STORE :@ TBXSCROLLINPUTLINE . STORE );CONST RBXSCROLLWINDOW :TSTREAMREC =(OBJTYPE :5353 ;
VMTLINK :OFS (TYPEOF (TBXSCROLLWINDOW )^);LOAD :@ TBXSCROLLWINDOW . LOAD ;STORE :@ TBXSCROLLWINDOW . STORE );
IMPLEMENTATION CONSTRUCTOR TBXSCROLLGROUP.INIT (VAR BOUNDS:TRECT;AHSCROLLBAR:PSCROLLBAR;AVSCROLLBAR:PSCROLLBAR);
BEGIN INHERITED INIT(BOUNDS );HSCROLLBAR := AHSCROLLBAR ;VSCROLLBAR := AVSCROLLBAR ;GROWMODE := GROWMODE OR GFGROWHIX OR
GFGROWHIY ;AUTOPOS := TRUE ;END ;CONSTRUCTOR TBXSCROLLGROUP.LOAD (VAR S:TSTREAM);BEGIN INHERITED LOAD(S );GETPEERVIEWPTR
(S , HSCROLLBAR );GETPEERVIEWPTR (S , VSCROLLBAR );S.READ (OLDPOS , SIZEOF (TPOINT ));S.READ (AUTOPOS , SIZEOF (BOOLEAN
));END ;PROCEDURE TBXSCROLLGROUP.HANDLEEVENT (VAR EVENT:TEVENT);VAR O1OllII1lOI0:TEVENT;O1I10Ol1:INTEGER;
O1I1Il0I:INTEGER;OI1I1O1lll10:TPOINT;PROCEDURE OIlI0lO101O (OO10:PVIEW);FAR ;BEGIN IF (OO10 ^. GROWMODE AND GFSCROLLXY <>
0 )THEN BEGIN OO10 ^. ORIGIN.X := OO10 ^. ORIGIN.X + O1I10Ol1 ;OO10 ^. ORIGIN.Y := OO10 ^. ORIGIN.Y + O1I1Il0I ;END ;
END ;PROCEDURE O1OlOO0110 ;BEGIN IF (CURRENT <> NIL )THEN BEGIN O1I10Ol1 := 0 ;O1I1Il0I := 0 ;IF (HSCROLLBAR <> NIL )THEN
BEGIN IF (CURRENT ^. ORIGIN.X < 0 )THEN HSCROLLBAR ^. VALUE := HSCROLLBAR ^. VALUE + CURRENT ^. ORIGIN.X ELSE IF (CURRENT
^. ORIGIN.X + CURRENT ^. SIZE.X > SIZE.X )THEN HSCROLLBAR ^. VALUE := HSCROLLBAR ^. VALUE + (CURRENT ^. ORIGIN.X +
CURRENT ^. SIZE.X - SIZE.X );O1I10Ol1 := OLDPOS.X - HSCROLLBAR ^. VALUE ;IF (O1I10Ol1 <> 0 )THEN BEGIN OLDPOS.X :=
HSCROLLBAR ^. VALUE ;HSCROLLBAR ^. DRAWVIEW ;END ;END ;IF (VSCROLLBAR <> NIL )THEN BEGIN IF (CURRENT ^. ORIGIN.Y < 0
)THEN VSCROLLBAR ^. VALUE := VSCROLLBAR ^. VALUE + CURRENT ^. ORIGIN.Y ELSE IF (CURRENT ^. ORIGIN.Y + CURRENT ^. SIZE.Y >
SIZE.Y )THEN VSCROLLBAR ^. VALUE := VSCROLLBAR ^. VALUE + (CURRENT ^. ORIGIN.Y + CURRENT ^. SIZE.Y - SIZE.Y );O1I1Il0I :=
OLDPOS.Y - VSCROLLBAR ^. VALUE ;IF (O1I1Il0I <> 0 )THEN BEGIN OLDPOS.Y := VSCROLLBAR ^. VALUE ;VSCROLLBAR ^. DRAWVIEW ;
END ;END ;END ;END ;BEGIN IF (EVENT.WHAT =EVBROADCAST )THEN CASE EVENT.COMMAND  OF CMSCROLLBARCHANGED :IF (EVENT.INFOPTR
<> NIL )THEN IF (HSCROLLBAR <> NIL )OR (VSCROLLBAR <> NIL )THEN BEGIN O1I10Ol1 := 0 ;O1I1Il0I := 0 ;IF (HSCROLLBAR
=EVENT.INFOPTR )THEN BEGIN O1I10Ol1 := OLDPOS.X - HSCROLLBAR ^. VALUE ;OLDPOS.X := HSCROLLBAR ^. VALUE ;END ELSE IF
(VSCROLLBAR =EVENT.INFOPTR )THEN BEGIN O1I1Il0I := OLDPOS.Y - VSCROLLBAR ^. VALUE ;OLDPOS.Y := VSCROLLBAR ^. VALUE ;
END ;IF (O1I10Ol1 <> 0 )OR (O1I1Il0I <> 0 )THEN BEGIN FOREACH (@ OIlI0lO101O );REDRAW ;IF (CURRENT <> NIL )THEN IF
(CURRENT ^. STATE AND SFCURSORVIS <> 0 )THEN CURRENT ^. SETCURSOR (CURRENT ^. CURSOR.X , CURRENT ^. CURSOR.Y );END ;EXIT
;END ;END ELSE IF (EVENT.WHAT =EVKEYDOWN )THEN CASE EVENT.KEYCODE  OF KBTAB :BEGIN FOCUSNEXT (FALSE );IF AUTOPOS THEN
BEGIN O1OlOO0110 ;IF (O1I10Ol1 <> 0 )OR (O1I1Il0I <> 0 )THEN BEGIN FOREACH (@ OIlI0lO101O );REDRAW ;END ;END ;CLEAREVENT
(EVENT );EXIT ;END ;KBSHIFTTAB :BEGIN FOCUSNEXT (TRUE );IF AUTOPOS THEN BEGIN O1OlOO0110 ;IF (O1I10Ol1 <> 0 )OR (O1I1Il0I
<> 0 )THEN BEGIN FOREACH (@ OIlI0lO101O );REDRAW ;END ;END ;CLEAREVENT (EVENT );EXIT ;END ;END ;O1OllII1lOI0 := EVENT ;
INHERITED HANDLEEVENT(EVENT );IF (O1OllII1lOI0.WHAT AND EVMOUSEDOWN <> 0 )AND AUTOPOS THEN BEGIN IF (CURRENT <> NIL )AND
CURRENT ^. MOUSEINVIEW (O1OllII1lOI0.WHERE )THEN BEGIN O1OlOO0110 ;IF (O1I10Ol1 <> 0 )OR (O1I1Il0I <> 0 )THEN
BEGIN FOREACH (@ OIlI0lO101O );REDRAW ;END ;END ;END ;END ;PROCEDURE TBXSCROLLGROUP.STORE (VAR S:TSTREAM);
BEGIN INHERITED STORE(S );PUTPEERVIEWPTR (S , HSCROLLBAR );PUTPEERVIEWPTR (S , VSCROLLBAR );S.WRITE (OLDPOS , SIZEOF
(TPOINT ));S.WRITE (AUTOPOS , SIZEOF (BOOLEAN ));END ;CONSTRUCTOR TBXSCROLLDIALOG.INIT (VAR BOUNDS:TRECT;ATITLE:STRING ;
OFFLAG:WORD);VAR OO1I:TRECT;OO10:PVIEW;BEGIN INHERITED INIT(BOUNDS , ATITLE );IF (OFFLAG AND OFHSCROLLBAR <> 0 )THEN
BEGIN HSCROLLBAR := STANDARDSCROLLBAR (SBHORIZONTAL OR SBHANDLEKEYBOARD );INSERT (HSCROLLBAR );END ;IF (OFFLAG AND
OFVSCROLLBAR <> 0 )THEN BEGIN VSCROLLBAR := STANDARDSCROLLBAR (SBVERTICAL OR SBHANDLEKEYBOARD );INSERT (VSCROLLBAR );
END ;GETEXTENT (OO1I );OO1I.GROW (- 1 , - 1 );INTERIOR := NEW (PBXSCROLLGROUP , INIT (OO1I , HSCROLLBAR , VSCROLLBAR ));
INSERT (INTERIOR );INTERIOR ^. INSERT (INITBACKGROUND );END ;CONSTRUCTOR TBXSCROLLDIALOG.LOAD (VAR S:TSTREAM);
BEGIN INHERITED LOAD(S );S.READ (LIMIT , SIZEOF (TPOINT ));GETSUBVIEWPTR (S , VSCROLLBAR );GETSUBVIEWPTR (S , HSCROLLBAR
);GETSUBVIEWPTR (S , INTERIOR );END ;PROCEDURE TBXSCROLLDIALOG.AUTOPOSITION (ENABLE:BOOLEAN);BEGIN INTERIOR ^. AUTOPOS :=
ENABLE ;END ;FUNCTION TBXSCROLLDIALOG.INITBACKGROUND :PVIEW ;VAR OO1I:TRECT;OO10:PVIEW;BEGIN INTERIOR ^. GETEXTENT (OO1I
);OO10 := NEW (PVIEW , INIT (OO1I ));OO10 ^. SETSTATE (SFDISABLED , TRUE );OO10 ^. OPTIONS := OO10 ^. OPTIONS AND NOT
OFSELECTABLE ;INITBACKGROUND := OO10 ;END ;PROCEDURE TBXSCROLLDIALOG.INSERTTOSCROLL (P:PVIEW);BEGIN INTERIOR ^. INSERT (P
);P ^. GROWMODE := P ^. GROWMODE OR GFSCROLLXY ;END ;PROCEDURE TBXSCROLLDIALOG.SETLIMIT (X,Y:INTEGER);BEGIN LIMIT.X := X
;LIMIT.Y := Y ;IF (HSCROLLBAR <> NIL )THEN HSCROLLBAR ^. SETPARAMS (HSCROLLBAR ^. VALUE , 0 , X - SIZE.X , SIZE.X - 1 , 1
);IF (VSCROLLBAR <> NIL )THEN VSCROLLBAR ^. SETPARAMS (VSCROLLBAR ^. VALUE , 0 , Y - SIZE.Y , SIZE.Y - 1 , 1 );END ;
PROCEDURE TBXSCROLLDIALOG.STORE (VAR S:TSTREAM);BEGIN INHERITED STORE(S );S.WRITE (LIMIT , SIZEOF (TPOINT ));
PUTSUBVIEWPTR (S , VSCROLLBAR );PUTSUBVIEWPTR (S , HSCROLLBAR );PUTSUBVIEWPTR (S , INTERIOR );END ;
CONSTRUCTOR TBXSCROLLVIEW.INIT (VAR BOUNDS:TRECT);BEGIN INHERITED INIT(BOUNDS );OPTIONS := OPTIONS OR OFSELECTABLE ;
DRAGMODE := DMDRAGMOVE OR DMDRAGGROW ;EVENTMASK := EVENTMASK OR EVBROADCAST ;END ;PROCEDURE TBXSCROLLVIEW.HANDLEEVENT
(VAR EVENT:TEVENT);PROCEDURE O10O0101OIIII (OI0ll01lOl0l:BYTE);VAR O10OOI0I1l0IO:TRECT;OIO0O1OlIlO,OIll00l10I0:TPOINT;
BEGIN IF (DRAGMODE AND OI0ll01lOl0l <> 0 )THEN BEGIN OWNER ^. GETEXTENT (O10OOI0I1l0IO );SIZELIMITS (OIO0O1OlIlO ,
OIll00l10I0 );OI0ll01lOl0l := OI0ll01lOl0l OR DRAGMODE AND NOT DMDRAGMOVE AND NOT DMDRAGGROW ;DRAGVIEW (EVENT ,
OI0ll01lOl0l , O10OOI0I1l0IO , OIO0O1OlIlO , OIll00l10I0 );CLEAREVENT (EVENT );END ;END ;VAR OI1I1O1lll10:TPOINT;
BEGIN INHERITED HANDLEEVENT(EVENT );IF (EVENT.WHAT =EVCOMMAND )THEN BEGIN CASE EVENT.COMMAND  OF CMDRAGVIEW
:O10O0101OIIII (DMDRAGMOVE OR DMDRAGGROW );END ;END ELSE IF (EVENT.WHAT =EVBROADCAST )THEN BEGIN CASE EVENT.COMMAND
 OF CMRECEIVEDFOCUS , CMRELEASEDFOCUS :DRAWVIEW ;END ;END ELSE IF (EVENT.WHAT =EVMOUSEDOWN )THEN BEGIN MAKELOCAL
(EVENT.WHERE , OI1I1O1lll10 );IF (OI1I1O1lll10.Y =0 )AND (OI1I1O1lll10.X < SIZE.X - 1 )THEN O10O0101OIIII (DMDRAGMOVE
)ELSE IF (OI1I1O1lll10.X >= SIZE.X - 1 )AND (OI1I1O1lll10.Y >= SIZE.Y - 1 )THEN O10O0101OIIII (DMDRAGGROW );END ;END ;
PROCEDURE TBXSCROLLVIEW.SETSTATE (ASTATE:WORD;ENABLE:BOOLEAN);BEGIN INHERITED SETSTATE(ASTATE , ENABLE );IF (ASTATE
=SFSELECTED )THEN SETSTATE (SFACTIVE , ENABLE )ELSE IF (ASTATE AND (SFDRAGGING OR SFACTIVE )<> 0 )THEN DRAWVIEW ;END ;
FUNCTION TBXSCROLLINPUTLINE.GETPALETTE :PPALETTE ;CONST OO10:STRING [ LENGTH(CSCROLLINPUTLINE)] =CSCROLLINPUTLINE;
BEGIN GETPALETTE := @ OO10 ;END ;CONSTRUCTOR TBXSCROLLWINDOW.INIT (VAR BOUNDS:TRECT;ATITLE:STRING ;ANUMBER:WORD;
OFFLAG:WORD);VAR OO1I:TRECT;BEGIN INHERITED INIT(BOUNDS , ATITLE , ANUMBER );IF (OFFLAG AND OFHSCROLLBAR <> 0 )THEN
BEGIN HSCROLLBAR := STANDARDSCROLLBAR (SBHORIZONTAL OR SBHANDLEKEYBOARD );INSERT (HSCROLLBAR );END ;IF (OFFLAG AND
OFVSCROLLBAR <> 0 )THEN BEGIN VSCROLLBAR := STANDARDSCROLLBAR (SBVERTICAL OR SBHANDLEKEYBOARD );INSERT (VSCROLLBAR );
END ;GETEXTENT (OO1I );OO1I.GROW (- 1 , - 1 );INTERIOR := NEW (PBXSCROLLGROUP , INIT (OO1I , HSCROLLBAR , VSCROLLBAR ));
INSERT (INTERIOR );INTERIOR ^. INSERT (INITBACKGROUND );END ;CONSTRUCTOR TBXSCROLLWINDOW.LOAD (VAR S:TSTREAM);
BEGIN INHERITED LOAD(S );GETSUBVIEWPTR (S , INTERIOR );END ;PROCEDURE TBXSCROLLWINDOW.AUTOPOSITION (ENABLE:BOOLEAN);
BEGIN INTERIOR ^. AUTOPOS := ENABLE ;END ;PROCEDURE TBXSCROLLWINDOW.CHANGEBOUNDS (VAR BOUNDS:TRECT);
BEGIN INHERITED CHANGEBOUNDS(BOUNDS );IF (HSCROLLBAR <> NIL )THEN HSCROLLBAR ^. SETPARAMS (HSCROLLBAR ^. VALUE , 0 ,
LIMIT.X - SIZE.X + 2 , SIZE.X - 1 , 1 );IF (VSCROLLBAR <> NIL )THEN VSCROLLBAR ^. SETPARAMS (VSCROLLBAR ^. VALUE , 0 ,
LIMIT.Y - SIZE.Y + 2 , SIZE.Y - 1 , 1 );END ;FUNCTION TBXSCROLLWINDOW.INITBACKGROUND :PVIEW ;VAR OO1I:TRECT;OO10:PVIEW;
BEGIN INTERIOR ^. GETEXTENT (OO1I );OO10 := NEW (PVIEW , INIT (OO1I ));OO10 ^. SETSTATE (SFDISABLED , TRUE );OO10 ^.
OPTIONS := OO10 ^. OPTIONS AND NOT OFSELECTABLE ;INITBACKGROUND := OO10 ;END ;PROCEDURE TBXSCROLLWINDOW.INSERTTOSCROLL
(P:PVIEW);BEGIN INTERIOR ^. INSERT (P );P ^. GROWMODE := P ^. GROWMODE OR GFSCROLLXY ;END ;
PROCEDURE TBXSCROLLWINDOW.SETLIMIT (X,Y:INTEGER);BEGIN LIMIT.X := X ;LIMIT.Y := Y ;IF (HSCROLLBAR <> NIL )THEN HSCROLLBAR
^. SETPARAMS (HSCROLLBAR ^. VALUE , 0 , X - SIZE.X , SIZE.X - 1 , 1 );IF (VSCROLLBAR <> NIL )THEN VSCROLLBAR ^. SETPARAMS
(VSCROLLBAR ^. VALUE , 0 , Y - SIZE.Y , SIZE.Y - 1 , 1 );END ;PROCEDURE TBXSCROLLWINDOW.STORE (VAR S:TSTREAM);
BEGIN INHERITED STORE(S );PUTSUBVIEWPTR (S , INTERIOR );END ;PROCEDURE REGISTERTVSCROLL ;BEGIN REGISTERTYPE
(RBXSCROLLGROUP );REGISTERTYPE (RBXSCROLLDIALOG );REGISTERTYPE (RBXSCROLLINPUTLINE );REGISTERTYPE (RBXSCROLLWINDOW );
END ;END .
